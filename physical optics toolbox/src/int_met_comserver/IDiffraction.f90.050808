!
!  IDiffraction.f90 - This module contains the interfaces of methods 
!  of the IDiffraction interface
!
!  Generated by the Visual Fortran COM Server Wizard on
!  08/01/05 at 17:23:47.
!
!   DO NOT EDIT THIS FILE!
!
!  This file is re-generated every time the object hierarchy is changed.
!

module IDiffraction_Methods

    !  These routines get implemented by the user
    interface 
        function IDiffraction_get_dx( ObjectData ,&
                 VALUE) result (hresult)
            use Diffraction_Types
            type(Diffraction_InstanceData) ObjectData
            !dec$ attributes reference :: ObjectData
            REAL(8), intent(out) :: VALUE
            integer(LONG) hresult
        end function
        function IDiffraction_get_dy( ObjectData ,&
                 VALUE) result (hresult)
            use Diffraction_Types
            type(Diffraction_InstanceData) ObjectData
            !dec$ attributes reference :: ObjectData
            REAL(8), intent(out) :: VALUE
            integer(LONG) hresult
        end function
        function IDiffraction_get_wavelength( ObjectData ,&
                 VALUE) result (hresult)
            use Diffraction_Types
            type(Diffraction_InstanceData) ObjectData
            !dec$ attributes reference :: ObjectData
            REAL(8), intent(out) :: VALUE
            integer(LONG) hresult
        end function
        function IDiffraction_get_curvature( ObjectData ,&
                 VALUE) result (hresult)
            use Diffraction_Types
            type(Diffraction_InstanceData) ObjectData
            !dec$ attributes reference :: ObjectData
            REAL(8), intent(out) :: VALUE
            integer(LONG) hresult
        end function
        function IDiffraction_get_Nx( ObjectData ,&
                 VALUE) result (hresult)
            use Diffraction_Types
            type(Diffraction_InstanceData) ObjectData
            !dec$ attributes reference :: ObjectData
            INTEGER(4), intent(out) :: VALUE
            integer(LONG) hresult
        end function
        function IDiffraction_get_Ny( ObjectData ,&
                 VALUE) result (hresult)
            use Diffraction_Types
            type(Diffraction_InstanceData) ObjectData
            !dec$ attributes reference :: ObjectData
            INTEGER(4), intent(out) :: VALUE
            integer(LONG) hresult
        end function
        function IDiffraction_x_vector_get( ObjectData ,&
                 BeamID,&
                 x_vector) result (hresult)
            use Diffraction_Types
            type(Diffraction_InstanceData) ObjectData
            !dec$ attributes reference :: ObjectData
            INTEGER(4), intent(in) :: BeamID
            REAL(8), intent(inout) :: x_vector
            DIMENSION x_vector(1:,1:)
            integer(LONG) hresult
        end function
        function IDiffraction_y_vector_get( ObjectData ,&
                 BeamID,&
                 y_vector) result (hresult)
            use Diffraction_Types
            type(Diffraction_InstanceData) ObjectData
            !dec$ attributes reference :: ObjectData
            INTEGER(4), intent(in) :: BeamID
            REAL(8), intent(inout) :: y_vector
            DIMENSION y_vector(1:,1:)
            integer(LONG) hresult
        end function
        function IDiffraction_wavefront_put( ObjectData ,&
                 amp_r,&
                 amp_i,&
                 dx,&
                 dy,&
                 wavelength,&
                 curv,&
                 BeamID,&
                 status) result (hresult)
            use Diffraction_Types
            type(Diffraction_InstanceData) ObjectData
            !dec$ attributes reference :: ObjectData
            REAL(8), intent(in) :: amp_r
            DIMENSION amp_r(1:,1:)
            REAL(8), intent(in) :: amp_i
            DIMENSION amp_i(1:,1:)
            REAL(8), intent(in) :: dx
            REAL(8), intent(in) :: dy
            REAL(8), intent(in) :: wavelength
            REAL(8), intent(in) :: curv
            INTEGER(4), intent(in) :: BeamID
            INTEGER(4), intent(out) :: status
            integer(LONG) hresult
        end function
        function IDiffraction_wavefront_get( ObjectData ,&
                 BeamID,&
                 amp_r,&
                 amp_i) result (hresult)
            use Diffraction_Types
            type(Diffraction_InstanceData) ObjectData
            !dec$ attributes reference :: ObjectData
            INTEGER(4), intent(in) :: BeamID
            REAL(8), intent(inout) :: amp_r
            DIMENSION amp_r(1:,1:)
            REAL(8), intent(inout) :: amp_i
            DIMENSION amp_i(1:,1:)
            integer(LONG) hresult
        end function
        function IDiffraction_CopyWavefront( ObjectData ,&
                 BeamIDfrom,&
                 BeamIDto,&
                 status) result (hresult)
            use Diffraction_Types
            type(Diffraction_InstanceData) ObjectData
            !dec$ attributes reference :: ObjectData
            INTEGER(4), intent(in) :: BeamIDfrom
            INTEGER(4), intent(in) :: BeamIDto
            INTEGER(4), intent(out) :: status
            integer(LONG) hresult
        end function
        function IDiffraction_CopyWavefrontAmp( ObjectData ,&
                 BeamIDAmp,&
                 BeamIDPhase,&
                 status) result (hresult)
            use Diffraction_Types
            type(Diffraction_InstanceData) ObjectData
            !dec$ attributes reference :: ObjectData
            INTEGER(4), intent(in) :: BeamIDAmp
            INTEGER(4), intent(in) :: BeamIDPhase
            INTEGER(4), intent(out) :: status
            integer(LONG) hresult
        end function
        function IDiffraction_SumWavefront( ObjectData ,&
                 BeamID,&
                 BeamIDadd,&
                 status) result (hresult)
            use Diffraction_Types
            type(Diffraction_InstanceData) ObjectData
            !dec$ attributes reference :: ObjectData
            INTEGER(4), intent(in) :: BeamID
            INTEGER(4), intent(in) :: BeamIDadd
            INTEGER(4), intent(out) :: status
            integer(LONG) hresult
        end function
        function IDiffraction_GetWavefrontParms( ObjectData ,&
                 BeamID,&
                 Nx,&
                 Ny,&
                 dx,&
                 dy,&
                 curv,&
                 wavelength) result (hresult)
            use Diffraction_Types
            type(Diffraction_InstanceData) ObjectData
            !dec$ attributes reference :: ObjectData
            INTEGER(4), intent(in) :: BeamID
            INTEGER(4), intent(out) :: Nx
            INTEGER(4), intent(out) :: Ny
            REAL(8), intent(out) :: dx
            REAL(8), intent(out) :: dy
            REAL(8), intent(out) :: curv
            REAL(8), intent(out) :: wavelength
            integer(LONG) hresult
        end function
        function IDiffraction_WriteWavefrontUNF( ObjectData ,&
                 StrFilename,&
                 BeamID,&
                 status) result (hresult)
            use Diffraction_Types
            type(Diffraction_InstanceData) ObjectData
            !dec$ attributes reference :: ObjectData
            CHARACTER(*), intent(in) :: StrFilename
            INTEGER(4), intent(in) :: BeamID
            INTEGER(4), intent(out) :: status
            integer(LONG) hresult
        end function
        function IDiffraction_ReadWavefrontUNF( ObjectData ,&
                 StrFilename,&
                 BeamID,&
                 status) result (hresult)
            use Diffraction_Types
            type(Diffraction_InstanceData) ObjectData
            !dec$ attributes reference :: ObjectData
            CHARACTER(*), intent(in) :: StrFilename
            INTEGER(4), intent(in) :: BeamID
            INTEGER(4), intent(out) :: status
            integer(LONG) hresult
        end function
        function IDiffraction_WavefrontPower( ObjectData ,&
                 power,&
                 BeamID) result (hresult)
            use Diffraction_Types
            type(Diffraction_InstanceData) ObjectData
            !dec$ attributes reference :: ObjectData
            REAL(8), intent(out) :: power
            INTEGER(4), intent(in), optional :: BeamID
            integer(LONG) hresult
        end function
        function IDiffraction_ApplyMask( ObjectData ,&
                 length_r,&
                 length_t,&
                 offset,&
                 direction) result (hresult)
            use Diffraction_Types
            type(Diffraction_InstanceData) ObjectData
            !dec$ attributes reference :: ObjectData
            REAL(8), intent(in) :: length_r
            REAL(8), intent(in) :: length_t
            REAL(8), intent(in) :: offset
            CHARACTER(*), intent(in) :: direction
            integer(LONG) hresult
        end function
        function IDiffraction_ApplyMaskMisalign( ObjectData ,&
                 length_r,&
                 length_t,&
                 offset,&
                 xc,&
                 yc,&
                 direction) result (hresult)
            use Diffraction_Types
            type(Diffraction_InstanceData) ObjectData
            !dec$ attributes reference :: ObjectData
            REAL(8), intent(in) :: length_r
            REAL(8), intent(in) :: length_t
            REAL(8), intent(in) :: offset
            REAL(8), intent(in) :: xc
            REAL(8), intent(in) :: yc
            CHARACTER(*), intent(in) :: direction
            integer(LONG) hresult
        end function
        function IDiffraction_ApplyMaskGeneral( ObjectData ,&
                 len_x,&
                 len_y,&
                 off_x,&
                 off_y) result (hresult)
            use Diffraction_Types
            type(Diffraction_InstanceData) ObjectData
            !dec$ attributes reference :: ObjectData
            REAL(8), intent(in) :: len_x
            REAL(8), intent(in) :: len_y
            REAL(8), intent(in) :: off_x
            REAL(8), intent(in) :: off_y
            integer(LONG) hresult
        end function
        function IDiffraction_ApplyMaskPoly( ObjectData ,&
                 vertices,&
                 xc,&
                 yc) result (hresult)
            use Diffraction_Types
            type(Diffraction_InstanceData) ObjectData
            !dec$ attributes reference :: ObjectData
            REAL(8), intent(in) :: vertices
            DIMENSION vertices(1:,1:)
            REAL(8), intent(in) :: xc
            REAL(8), intent(in) :: yc
            integer(LONG) hresult
        end function
        function IDiffraction_ApplyMaskX( ObjectData ,&
                 radius,&
                 length) result (hresult)
            use Diffraction_Types
            type(Diffraction_InstanceData) ObjectData
            !dec$ attributes reference :: ObjectData
            REAL(8), intent(in) :: radius
            REAL(8), intent(in) :: length
            integer(LONG) hresult
        end function
        function IDiffraction_ApplyMaskXRounded( ObjectData ,&
                 radius,&
                 length,&
                 corner_rad) result (hresult)
            use Diffraction_Types
            type(Diffraction_InstanceData) ObjectData
            !dec$ attributes reference :: ObjectData
            REAL(8), intent(in) :: radius
            REAL(8), intent(in) :: length
            REAL(8), intent(in) :: corner_rad
            integer(LONG) hresult
        end function
        function IDiffraction_ApplyMaskRotate( ObjectData ,&
                 length_r,&
                 length_t,&
                 offset,&
                 angle,&
                 xc,&
                 yc,&
                 direction,&
                 BeamID,&
                 status) result (hresult)
            use Diffraction_Types
            type(Diffraction_InstanceData) ObjectData
            !dec$ attributes reference :: ObjectData
            REAL(8), intent(in) :: length_r
            REAL(8), intent(in) :: length_t
            REAL(8), intent(in) :: offset
            REAL(8), intent(in) :: angle
            REAL(8), intent(in) :: xc
            REAL(8), intent(in) :: yc
            CHARACTER(*), intent(in) :: direction
            INTEGER(4), intent(in) :: BeamID
            INTEGER(4), intent(out) :: status
            integer(LONG) hresult
        end function
        function IDiffraction_ApplyMaskTilt( ObjectData ,&
                 length_r,&
                 length_t,&
                 offset,&
                 rotangle,&
                 xc,&
                 yc,&
                 tiltangle,&
                 tiltorientation,&
                 direction,&
                 BeamID,&
                 status) result (hresult)
            use Diffraction_Types
            type(Diffraction_InstanceData) ObjectData
            !dec$ attributes reference :: ObjectData
            REAL(8), intent(in) :: length_r
            REAL(8), intent(in) :: length_t
            REAL(8), intent(in) :: offset
            REAL(8), intent(in) :: rotangle
            REAL(8), intent(in) :: xc
            REAL(8), intent(in) :: yc
            REAL(8), intent(in) :: tiltangle
            REAL(8), intent(in) :: tiltorientation
            CHARACTER(*), intent(in) :: direction
            INTEGER(4), intent(in) :: BeamID
            INTEGER(4), intent(out) :: status
            integer(LONG) hresult
        end function
        function IDiffraction_CreateGausSource( ObjectData ,&
                 BeamWaistDiam,&
                 Nx,&
                 Ny,&
                 dx,&
                 dy,&
                 wavelength,&
                 BeamID,&
                 status) result (hresult)
            use Diffraction_Types
            type(Diffraction_InstanceData) ObjectData
            !dec$ attributes reference :: ObjectData
            REAL(8), intent(in) :: BeamWaistDiam
            INTEGER(4), intent(in) :: Nx
            INTEGER(4), intent(in) :: Ny
            REAL(8), intent(in) :: dx
            REAL(8), intent(in) :: dy
            REAL(8), intent(in) :: wavelength
            INTEGER(4), intent(in) :: BeamID
            INTEGER(4), intent(out) :: status
            integer(LONG) hresult
        end function
        function IDiffraction_CreateTophatSource( ObjectData ,&
                 BeamDiam,&
                 Nx,&
                 Ny,&
                 dx,&
                 dy,&
                 wavelength,&
                 BeamID,&
                 status) result (hresult)
            use Diffraction_Types
            type(Diffraction_InstanceData) ObjectData
            !dec$ attributes reference :: ObjectData
            REAL(8), intent(in) :: BeamDiam
            INTEGER(4), intent(in) :: Nx
            INTEGER(4), intent(in) :: Ny
            REAL(8), intent(in) :: dx
            REAL(8), intent(in) :: dy
            REAL(8), intent(in) :: wavelength
            INTEGER(4), intent(in) :: BeamID
            INTEGER(4), intent(out) :: status
            integer(LONG) hresult
        end function
        function IDiffraction_Propagate( ObjectData ,&
                 Distance,&
                 BeamID) result (hresult)
            use Diffraction_Types
            type(Diffraction_InstanceData) ObjectData
            !dec$ attributes reference :: ObjectData
            REAL(8), intent(in) :: Distance
            INTEGER(4), intent(in) :: BeamID
            integer(LONG) hresult
        end function
        function IDiffraction_PropagateExt( ObjectData ,&
                 Distance,&
                 dxout,&
                 dyout,&
                 applyCurv,&
                 BeamID,&
                 status) result (hresult)
            use Diffraction_Types
            type(Diffraction_InstanceData) ObjectData
            !dec$ attributes reference :: ObjectData
            REAL(8), intent(in) :: Distance
            REAL(8), intent(in) :: dxout
            REAL(8), intent(in) :: dyout
            LOGICAL(4), intent(in) :: applyCurv
            INTEGER(4), intent(in) :: BeamID
            INTEGER(4), intent(out) :: status
            integer(LONG) hresult
        end function
        function IDiffraction_PropagateDefDx( ObjectData ,&
                 Distance) result (hresult)
            use Diffraction_Types
            type(Diffraction_InstanceData) ObjectData
            !dec$ attributes reference :: ObjectData
            REAL(8), intent(in) :: Distance
            integer(LONG) hresult
        end function
        function IDiffraction_CornerCube( ObjectData ,&
                 ccsize,&
                 shape,&
                 xc,&
                 yc,&
                 spin,&
                 gapwidth,&
                 rotmatrix,&
                 dihedral,&
                 edgelength) result (hresult)
            use Diffraction_Types
            type(Diffraction_InstanceData) ObjectData
            !dec$ attributes reference :: ObjectData
            REAL(8), intent(in) :: ccsize
            CHARACTER(*), intent(in) :: shape
            REAL(8), intent(in) :: xc
            REAL(8), intent(in) :: yc
            REAL(8), intent(in) :: spin
            REAL(8), intent(in) :: gapwidth
            DIMENSION gapwidth(1:,1:)
            REAL(8), intent(in) :: rotmatrix
            DIMENSION rotmatrix(1:,1:)
            REAL(8), intent(in) :: dihedral
            DIMENSION dihedral(1:,1:)
            REAL(8), intent(in) :: edgelength
            DIMENSION edgelength(1:,1:)
            integer(LONG) hresult
        end function
        function IDiffraction_focuslens( ObjectData ,&
                 focuslens_f,&
                 focuslens_D,&
                 dxout,&
                 dyout,&
                 BeamID,&
                 status) result (hresult)
            use Diffraction_Types
            type(Diffraction_InstanceData) ObjectData
            !dec$ attributes reference :: ObjectData
            REAL(8), intent(in) :: focuslens_f
            REAL(8), intent(in) :: focuslens_D
            REAL(8), intent(in) :: dxout
            REAL(8), intent(in) :: dyout
            INTEGER(4), intent(in) :: BeamID
            INTEGER(4), intent(out) :: status
            integer(LONG) hresult
        end function
        function IDiffraction_ThinLens( ObjectData ,&
                 focallength,&
                 diameter,&
                 xc,&
                 yc,&
                 BeamID,&
                 status) result (hresult)
            use Diffraction_Types
            type(Diffraction_InstanceData) ObjectData
            !dec$ attributes reference :: ObjectData
            REAL(8), intent(in) :: focallength
            REAL(8), intent(in) :: diameter
            REAL(8), intent(in) :: xc
            REAL(8), intent(in) :: yc
            INTEGER(4), intent(in) :: BeamID
            INTEGER(4), intent(out) :: status
            integer(LONG) hresult
        end function
        function IDiffraction_ReflectAsphere( ObjectData ,&
                 rCurv,&
                 conicConst,&
                 diam,&
                 xDecenter,&
                 yDecenter,&
                 incidenceAngle,&
                 azimuth,&
                 applyCurv) result (hresult)
            use Diffraction_Types
            type(Diffraction_InstanceData) ObjectData
            !dec$ attributes reference :: ObjectData
            REAL(8), intent(in) :: rCurv
            REAL(8), intent(in) :: conicConst
            REAL(8), intent(in) :: diam
            REAL(8), intent(in) :: xDecenter
            REAL(8), intent(in) :: yDecenter
            REAL(8), intent(in) :: incidenceAngle
            REAL(8), intent(in) :: azimuth
            INTEGER(4), intent(in) :: applyCurv
            integer(LONG) hresult
        end function
        function IDiffraction_PistonTiltFocus( ObjectData ,&
                 piston,&
                 xtilt,&
                 ytilt,&
                 focus,&
                 xc,&
                 yc) result (hresult)
            use Diffraction_Types
            type(Diffraction_InstanceData) ObjectData
            !dec$ attributes reference :: ObjectData
            REAL(8), intent(in) :: piston
            REAL(8), intent(in) :: xtilt
            REAL(8), intent(in) :: ytilt
            REAL(8), intent(in) :: focus
            REAL(8), intent(in) :: xc
            REAL(8), intent(in) :: yc
            integer(LONG) hresult
        end function
        function IDiffraction_PropagateToFocalPlane( ObjectData ,&
                 lens_f,&
                 lens_D,&
                 dxout,&
                 dyout,&
                 applycurv,&
                 BeamID,&
                 status) result (hresult)
            use Diffraction_Types
            type(Diffraction_InstanceData) ObjectData
            !dec$ attributes reference :: ObjectData
            REAL(8), intent(in) :: lens_f
            REAL(8), intent(in) :: lens_D
            REAL(8), intent(in) :: dxout
            REAL(8), intent(in) :: dyout
            LOGICAL(4), intent(in) :: applycurv
            INTEGER(4), intent(in) :: BeamID
            INTEGER(4), intent(out) :: status
            integer(LONG) hresult
        end function
        function IDiffraction_ClipCirc( ObjectData ,&
                 Diameter,&
                 xc,&
                 yc,&
                 obscDiam) result (hresult)
            use Diffraction_Types
            type(Diffraction_InstanceData) ObjectData
            !dec$ attributes reference :: ObjectData
            REAL(8), intent(in) :: Diameter
            REAL(8), intent(in) :: xc
            REAL(8), intent(in) :: yc
            REAL(8), intent(in), optional :: obscDiam
            integer(LONG) hresult
        end function
        function IDiffraction_ClipRect( ObjectData ,&
                 len_x,&
                 len_y,&
                 off_x,&
                 off_y,&
                 obscFlag) result (hresult)
            use Diffraction_Types
            type(Diffraction_InstanceData) ObjectData
            !dec$ attributes reference :: ObjectData
            REAL(8), intent(in) :: len_x
            REAL(8), intent(in) :: len_y
            REAL(8), intent(in) :: off_x
            REAL(8), intent(in) :: off_y
            INTEGER(4), intent(in), optional :: obscFlag
            integer(LONG) hresult
        end function
        function IDiffraction_ClipPolygon( ObjectData ,&
                 vertices,&
                 xc,&
                 yc,&
                 angle) result (hresult)
            use Diffraction_Types
            type(Diffraction_InstanceData) ObjectData
            !dec$ attributes reference :: ObjectData
            REAL(8), intent(in) :: vertices
            DIMENSION vertices(1:,1:)
            REAL(8), intent(in) :: xc
            REAL(8), intent(in) :: yc
            REAL(8), intent(in) :: angle
            integer(LONG) hresult
        end function
        function IDiffraction_ClipBWindow( ObjectData ,&
                 winT,&
                 winA,&
                 xc,&
                 yc,&
                 rotAngle) result (hresult)
            use Diffraction_Types
            type(Diffraction_InstanceData) ObjectData
            !dec$ attributes reference :: ObjectData
            REAL(8), intent(in) :: winT
            REAL(8), intent(in) :: winA
            REAL(8), intent(in) :: xc
            REAL(8), intent(in) :: yc
            REAL(8), intent(in) :: rotAngle
            integer(LONG) hresult
        end function
        function IDiffraction_AddThreadCommand( ObjectData ,&
                 ThreadID,&
                 CmdID,&
                 rP,&
                 iP,&
                 pwAID,&
                 pwBID,&
                 strP,&
                 flagStatus) result (hresult)
            use Diffraction_Types
            type(Diffraction_InstanceData) ObjectData
            !dec$ attributes reference :: ObjectData
            INTEGER(4), intent(in) :: ThreadID
            INTEGER(4), intent(in) :: CmdID
            REAL(8), intent(in) :: rP
            DIMENSION rP(1:,1:)
            INTEGER(4), intent(in) :: iP
            DIMENSION iP(1:,1:)
            INTEGER(4), intent(in) :: pwAID
            INTEGER(4), intent(in) :: pwBID
            CHARACTER(*), intent(in) :: strP
            INTEGER(4), intent(out) :: flagStatus
            integer(LONG) hresult
        end function
        function IDiffraction_ExecuteThread( ObjectData ,&
                 ThreadID,&
                 flagStatus) result (hresult)
            use Diffraction_Types
            type(Diffraction_InstanceData) ObjectData
            !dec$ attributes reference :: ObjectData
            INTEGER(4), intent(in) :: ThreadID
            INTEGER(4), intent(out) :: flagStatus
            integer(LONG) hresult
        end function
        function IDiffraction_ThreadStatus( ObjectData ,&
                 ThreadID,&
                 flagStatus) result (hresult)
            use Diffraction_Types
            type(Diffraction_InstanceData) ObjectData
            !dec$ attributes reference :: ObjectData
            INTEGER(4), intent(in) :: ThreadID
            INTEGER(4), intent(out) :: flagStatus
            integer(LONG) hresult
        end function
        function IDiffraction_WaitForThread( ObjectData ,&
                 ThreadID,&
                 TimeOutMS,&
                 WaitStatus) result (hresult)
            use Diffraction_Types
            type(Diffraction_InstanceData) ObjectData
            !dec$ attributes reference :: ObjectData
            INTEGER(4), intent(in) :: ThreadID
            INTEGER(4), intent(in) :: TimeOutMS
            INTEGER(4), intent(out) :: WaitStatus
            integer(LONG) hresult
        end function
        function IDiffraction_WaitForMultipleThreads( ObjectData ,&
                 pThreadID,&
                 TimeOutMS,&
                 flagWaitAll,&
                 WaitStatus) result (hresult)
            use Diffraction_Types
            type(Diffraction_InstanceData) ObjectData
            !dec$ attributes reference :: ObjectData
            INTEGER(4), intent(in) :: pThreadID
            DIMENSION pThreadID(1:,1:)
            INTEGER(4), intent(in) :: TimeOutMS
            INTEGER(4), intent(in) :: flagWaitAll
            INTEGER(4), intent(out) :: WaitStatus
            integer(LONG) hresult
        end function
        function IDiffraction_ClearThread( ObjectData ,&
                 ThreadID,&
                 flagStatus) result (hresult)
            use Diffraction_Types
            type(Diffraction_InstanceData) ObjectData
            !dec$ attributes reference :: ObjectData
            INTEGER(4), intent(in) :: ThreadID
            INTEGER(4), intent(out) :: flagStatus
            integer(LONG) hresult
        end function
        function IDiffraction_get_ThreadOPD( ObjectData ,&
                 ThreadID,&
                 OPDID,&
                 VALUE) result (hresult)
            use Diffraction_Types
            type(Diffraction_InstanceData) ObjectData
            !dec$ attributes reference :: ObjectData
            INTEGER(4), intent(in) :: ThreadID
            INTEGER(4), intent(in) :: OPDID
            REAL(8), intent(out) :: VALUE
            integer(LONG) hresult
        end function
        function IDiffraction_get_ThreadPOW( ObjectData ,&
                 ThreadID,&
                 POWID,&
                 VALUE) result (hresult)
            use Diffraction_Types
            type(Diffraction_InstanceData) ObjectData
            !dec$ attributes reference :: ObjectData
            INTEGER(4), intent(in) :: ThreadID
            INTEGER(4), intent(in) :: POWID
            REAL(8), intent(out) :: VALUE
            integer(LONG) hresult
        end function

    end interface

    !  Local definition of SysStringLen
    interface
        PURE INTEGER*4 FUNCTION SysStringLen_Local(bstr);
            !DEC$IF DEFINED(_X86_)
            !DEC$ ATTRIBUTES DEFAULT, STDCALL, ALIAS : '_SysStringLen@' :: SysStringLen_Local
            !DEC$ELSE
            !DEC$ ATTRIBUTES DEFAULT, STDCALL, ALIAS : 'SysStringLen' :: SysStringLen_Local
            !DEC$ENDIF
            USE DFWINTY
            INTEGER(INT_PTR_KIND()), INTENT(IN)    :: bstr
            !DEC$ ATTRIBUTES VALUE              :: bstr
        END FUNCTION SysStringLen_Local
    end interface

  contains

    !  Wrapper functions called from the Vtbl

    function $IDiffraction_get_dx( pInterface ,&
             VALUE ) result (hresult)
        !DEC$ ATTRIBUTES STDCALL :: $IDiffraction_get_dx
        use Diffraction_Types
        use dfcom
        use dflib
        implicit none
        type (IDiffraction_Ptr) pInterface
        !dec$ attributes reference :: pInterface
        REAL(8), intent(out) :: VALUE 
        !DEC$ ATTRIBUTES reference :: VALUE 
        integer(LONG) hresult
        integer i
		

        hresult = IDiffraction_get_dx(pInterface % pInternalData % pInstanceData ,&
             VALUE )
        
        if (hresult < 0) goto 9999
    9999  continue  ! Cleanup code
    end function
    function $IDiffraction_get_dy( pInterface ,&
             VALUE ) result (hresult)
        !DEC$ ATTRIBUTES STDCALL :: $IDiffraction_get_dy
        use Diffraction_Types
        use dfcom
        use dflib
        implicit none
        type (IDiffraction_Ptr) pInterface
        !dec$ attributes reference :: pInterface
        REAL(8), intent(out) :: VALUE 
        !DEC$ ATTRIBUTES reference :: VALUE 
        integer(LONG) hresult
        integer i
		

        hresult = IDiffraction_get_dy(pInterface % pInternalData % pInstanceData ,&
             VALUE )
        
        if (hresult < 0) goto 9999
    9999  continue  ! Cleanup code
    end function
    function $IDiffraction_get_wavelength( pInterface ,&
             VALUE ) result (hresult)
        !DEC$ ATTRIBUTES STDCALL :: $IDiffraction_get_wavelength
        use Diffraction_Types
        use dfcom
        use dflib
        implicit none
        type (IDiffraction_Ptr) pInterface
        !dec$ attributes reference :: pInterface
        REAL(8), intent(out) :: VALUE 
        !DEC$ ATTRIBUTES reference :: VALUE 
        integer(LONG) hresult
        integer i
		

        hresult = IDiffraction_get_wavelength(pInterface % pInternalData % pInstanceData ,&
             VALUE )
        
        if (hresult < 0) goto 9999
    9999  continue  ! Cleanup code
    end function
    function $IDiffraction_get_curvature( pInterface ,&
             VALUE ) result (hresult)
        !DEC$ ATTRIBUTES STDCALL :: $IDiffraction_get_curvature
        use Diffraction_Types
        use dfcom
        use dflib
        implicit none
        type (IDiffraction_Ptr) pInterface
        !dec$ attributes reference :: pInterface
        REAL(8), intent(out) :: VALUE 
        !DEC$ ATTRIBUTES reference :: VALUE 
        integer(LONG) hresult
        integer i
		

        hresult = IDiffraction_get_curvature(pInterface % pInternalData % pInstanceData ,&
             VALUE )
        
        if (hresult < 0) goto 9999
    9999  continue  ! Cleanup code
    end function
    function $IDiffraction_get_Nx( pInterface ,&
             VALUE ) result (hresult)
        !DEC$ ATTRIBUTES STDCALL :: $IDiffraction_get_Nx
        use Diffraction_Types
        use dfcom
        use dflib
        implicit none
        type (IDiffraction_Ptr) pInterface
        !dec$ attributes reference :: pInterface
        INTEGER(4), intent(out) :: VALUE 
        !DEC$ ATTRIBUTES reference :: VALUE 
        integer(LONG) hresult
        integer i
		

        hresult = IDiffraction_get_Nx(pInterface % pInternalData % pInstanceData ,&
             VALUE )
        
        if (hresult < 0) goto 9999
    9999  continue  ! Cleanup code
    end function
    function $IDiffraction_get_Ny( pInterface ,&
             VALUE ) result (hresult)
        !DEC$ ATTRIBUTES STDCALL :: $IDiffraction_get_Ny
        use Diffraction_Types
        use dfcom
        use dflib
        implicit none
        type (IDiffraction_Ptr) pInterface
        !dec$ attributes reference :: pInterface
        INTEGER(4), intent(out) :: VALUE 
        !DEC$ ATTRIBUTES reference :: VALUE 
        integer(LONG) hresult
        integer i
		

        hresult = IDiffraction_get_Ny(pInterface % pInternalData % pInstanceData ,&
             VALUE )
        
        if (hresult < 0) goto 9999
    9999  continue  ! Cleanup code
    end function
    function $IDiffraction_x_vector_get( pInterface ,&
             BeamID ,&
             x_vector ) result (hresult)
        !DEC$ ATTRIBUTES STDCALL :: $IDiffraction_x_vector_get
        use Diffraction_Types
        use dfcom
        use dflib
        implicit none
        type (IDiffraction_Ptr) pInterface
        !dec$ attributes reference :: pInterface
        INTEGER(4), intent(in) :: BeamID 
        !DEC$ ATTRIBUTES value :: BeamID 
        integer(INT_PTR_KIND()), intent(inout) :: x_vector 
        !DEC$ ATTRIBUTES reference :: x_vector 
        integer(LONG) hresult
        integer i
        REAL(8) f$x_vector(:,:)
        volatile f$x_vector
        pointer f$x_vector
        integer(INT_PTR_KIND()) ptr$x_vector
        integer(INT_PTR_KIND()) sa$x_vector
        integer dims$x_vector
        integer lb$x_vector(2)
        integer ub$x_vector(2)
        integer nb$x_vector(2)
        type (FOR_DIMS_INFO) da$x_vector(2) 
        sa$x_vector = NULL
        lb$x_vector = 0
        ub$x_vector = 0
        nb$x_vector = 0 
        
        dims$x_vector = SafeArrayGetDim(x_vector)
        if (dims$x_vector /= 2) then
            hresult = E_INVALIDARG
            goto 9999
        end if
        do i = 1, 2
            hresult = SafeArrayGetLBound(x_vector, i, lb$x_vector(i))
            hresult = SafeArrayGetUBound(x_vector, i, ub$x_vector(i))
            nb$x_vector(i) = ub$x_vector(i) - lb$x_vector(i) + 1
        end do
        hresult = SafeArrayAccessData(x_vector, ptr$x_vector)
        if (hresult < 0) goto 9999
        sa$x_vector = x_vector
        da$x_vector(1)%LowerBound = lb$x_vector(1)
        da$x_vector(1)%UpperBound = ub$x_vector(1)
        da$x_vector(1)%Stride = 1
        da$x_vector(2)%LowerBound = lb$x_vector(2)
        da$x_vector(2)%UpperBound = ub$x_vector(2)
        da$x_vector(2)%Stride = 1
        call FOR_DESCRIPTOR_ASSIGN(f$x_vector, ptr$x_vector, SIZEOF(f$x_vector(lb$x_vector(1), lb$x_vector(2))), &
             IOR(FOR_DESCRIPTOR_ARRAY_DEFINED, IOR(FOR_DESCRIPTOR_ARRAY_NODEALLOC, FOR_DESCRIPTOR_ARRAY_CONTIGUOUS)), &
             2, da$x_vector) 
		

        hresult = IDiffraction_x_vector_get(pInterface % pInternalData % pInstanceData ,&
             BeamID ,&
             f$x_vector )
        
        if (hresult < 0) goto 9999
    9999  continue  ! Cleanup code
        
        if (sa$x_vector /= NULL) i = SafeArrayUnaccessData(sa$x_vector) 
    end function
    function $IDiffraction_y_vector_get( pInterface ,&
             BeamID ,&
             y_vector ) result (hresult)
        !DEC$ ATTRIBUTES STDCALL :: $IDiffraction_y_vector_get
        use Diffraction_Types
        use dfcom
        use dflib
        implicit none
        type (IDiffraction_Ptr) pInterface
        !dec$ attributes reference :: pInterface
        INTEGER(4), intent(in) :: BeamID 
        !DEC$ ATTRIBUTES value :: BeamID 
        integer(INT_PTR_KIND()), intent(inout) :: y_vector 
        !DEC$ ATTRIBUTES reference :: y_vector 
        integer(LONG) hresult
        integer i
        REAL(8) f$y_vector(:,:)
        volatile f$y_vector
        pointer f$y_vector
        integer(INT_PTR_KIND()) ptr$y_vector
        integer(INT_PTR_KIND()) sa$y_vector
        integer dims$y_vector
        integer lb$y_vector(2)
        integer ub$y_vector(2)
        integer nb$y_vector(2)
        type (FOR_DIMS_INFO) da$y_vector(2) 
        sa$y_vector = NULL
        lb$y_vector = 0
        ub$y_vector = 0
        nb$y_vector = 0 
        
        dims$y_vector = SafeArrayGetDim(y_vector)
        if (dims$y_vector /= 2) then
            hresult = E_INVALIDARG
            goto 9999
        end if
        do i = 1, 2
            hresult = SafeArrayGetLBound(y_vector, i, lb$y_vector(i))
            hresult = SafeArrayGetUBound(y_vector, i, ub$y_vector(i))
            nb$y_vector(i) = ub$y_vector(i) - lb$y_vector(i) + 1
        end do
        hresult = SafeArrayAccessData(y_vector, ptr$y_vector)
        if (hresult < 0) goto 9999
        sa$y_vector = y_vector
        da$y_vector(1)%LowerBound = lb$y_vector(1)
        da$y_vector(1)%UpperBound = ub$y_vector(1)
        da$y_vector(1)%Stride = 1
        da$y_vector(2)%LowerBound = lb$y_vector(2)
        da$y_vector(2)%UpperBound = ub$y_vector(2)
        da$y_vector(2)%Stride = 1
        call FOR_DESCRIPTOR_ASSIGN(f$y_vector, ptr$y_vector, SIZEOF(f$y_vector(lb$y_vector(1), lb$y_vector(2))), &
             IOR(FOR_DESCRIPTOR_ARRAY_DEFINED, IOR(FOR_DESCRIPTOR_ARRAY_NODEALLOC, FOR_DESCRIPTOR_ARRAY_CONTIGUOUS)), &
             2, da$y_vector) 
		

        hresult = IDiffraction_y_vector_get(pInterface % pInternalData % pInstanceData ,&
             BeamID ,&
             f$y_vector )
        
        if (hresult < 0) goto 9999
    9999  continue  ! Cleanup code
        
        if (sa$y_vector /= NULL) i = SafeArrayUnaccessData(sa$y_vector) 
    end function
    function $IDiffraction_wavefront_put( pInterface ,&
             amp_r ,&
             amp_i ,&
             dx ,&
             dy ,&
             wavelength ,&
             curv ,&
             BeamID ,&
             status ) result (hresult)
        !DEC$ ATTRIBUTES STDCALL :: $IDiffraction_wavefront_put
        use Diffraction_Types
        use dfcom
        use dflib
        implicit none
        type (IDiffraction_Ptr) pInterface
        !dec$ attributes reference :: pInterface
        integer(INT_PTR_KIND()), intent(in) :: amp_r 
        !DEC$ ATTRIBUTES value :: amp_r 
        integer(INT_PTR_KIND()), intent(in) :: amp_i 
        !DEC$ ATTRIBUTES value :: amp_i 
        REAL(8), intent(in) :: dx 
        !DEC$ ATTRIBUTES value :: dx 
        REAL(8), intent(in) :: dy 
        !DEC$ ATTRIBUTES value :: dy 
        REAL(8), intent(in) :: wavelength 
        !DEC$ ATTRIBUTES value :: wavelength 
        REAL(8), intent(in) :: curv 
        !DEC$ ATTRIBUTES value :: curv 
        INTEGER(4), intent(in) :: BeamID 
        !DEC$ ATTRIBUTES value :: BeamID 
        INTEGER(4), intent(out) :: status 
        !DEC$ ATTRIBUTES reference :: status 
        integer(LONG) hresult
        integer i
        REAL(8) f$amp_r(:,:)
        volatile f$amp_r
        pointer f$amp_r
        integer(INT_PTR_KIND()) ptr$amp_r
        integer(INT_PTR_KIND()) sa$amp_r
        integer dims$amp_r
        integer lb$amp_r(2)
        integer ub$amp_r(2)
        integer nb$amp_r(2)
        type (FOR_DIMS_INFO) da$amp_r(2) 
        REAL(8) f$amp_i(:,:)
        volatile f$amp_i
        pointer f$amp_i
        integer(INT_PTR_KIND()) ptr$amp_i
        integer(INT_PTR_KIND()) sa$amp_i
        integer dims$amp_i
        integer lb$amp_i(2)
        integer ub$amp_i(2)
        integer nb$amp_i(2)
        type (FOR_DIMS_INFO) da$amp_i(2) 
        sa$amp_r = NULL
        lb$amp_r = 0
        ub$amp_r = 0
        nb$amp_r = 0 
        sa$amp_i = NULL
        lb$amp_i = 0
        ub$amp_i = 0
        nb$amp_i = 0 
        
        dims$amp_r = SafeArrayGetDim(amp_r)
        if (dims$amp_r /= 2) then
            hresult = E_INVALIDARG
            goto 9999
        end if
        do i = 1, 2
            hresult = SafeArrayGetLBound(amp_r, i, lb$amp_r(i))
            hresult = SafeArrayGetUBound(amp_r, i, ub$amp_r(i))
            nb$amp_r(i) = ub$amp_r(i) - lb$amp_r(i) + 1
        end do
        hresult = SafeArrayAccessData(amp_r, ptr$amp_r)
        if (hresult < 0) goto 9999
        sa$amp_r = amp_r
        da$amp_r(1)%LowerBound = lb$amp_r(1)
        da$amp_r(1)%UpperBound = ub$amp_r(1)
        da$amp_r(1)%Stride = 1
        da$amp_r(2)%LowerBound = lb$amp_r(2)
        da$amp_r(2)%UpperBound = ub$amp_r(2)
        da$amp_r(2)%Stride = 1
        call FOR_DESCRIPTOR_ASSIGN(f$amp_r, ptr$amp_r, SIZEOF(f$amp_r(lb$amp_r(1), lb$amp_r(2))), &
             IOR(FOR_DESCRIPTOR_ARRAY_DEFINED, IOR(FOR_DESCRIPTOR_ARRAY_NODEALLOC, FOR_DESCRIPTOR_ARRAY_CONTIGUOUS)), &
             2, da$amp_r) 
        
        dims$amp_i = SafeArrayGetDim(amp_i)
        if (dims$amp_i /= 2) then
            hresult = E_INVALIDARG
            goto 9999
        end if
        do i = 1, 2
            hresult = SafeArrayGetLBound(amp_i, i, lb$amp_i(i))
            hresult = SafeArrayGetUBound(amp_i, i, ub$amp_i(i))
            nb$amp_i(i) = ub$amp_i(i) - lb$amp_i(i) + 1
        end do
        hresult = SafeArrayAccessData(amp_i, ptr$amp_i)
        if (hresult < 0) goto 9999
        sa$amp_i = amp_i
        da$amp_i(1)%LowerBound = lb$amp_i(1)
        da$amp_i(1)%UpperBound = ub$amp_i(1)
        da$amp_i(1)%Stride = 1
        da$amp_i(2)%LowerBound = lb$amp_i(2)
        da$amp_i(2)%UpperBound = ub$amp_i(2)
        da$amp_i(2)%Stride = 1
        call FOR_DESCRIPTOR_ASSIGN(f$amp_i, ptr$amp_i, SIZEOF(f$amp_i(lb$amp_i(1), lb$amp_i(2))), &
             IOR(FOR_DESCRIPTOR_ARRAY_DEFINED, IOR(FOR_DESCRIPTOR_ARRAY_NODEALLOC, FOR_DESCRIPTOR_ARRAY_CONTIGUOUS)), &
             2, da$amp_i) 
		

        hresult = IDiffraction_wavefront_put(pInterface % pInternalData % pInstanceData ,&
             f$amp_r ,&
             f$amp_i ,&
             dx ,&
             dy ,&
             wavelength ,&
             curv ,&
             BeamID ,&
             status )
        
        if (hresult < 0) goto 9999
    9999  continue  ! Cleanup code
        
        if (sa$amp_r /= NULL) i = SafeArrayUnaccessData(sa$amp_r) 
        
        if (sa$amp_i /= NULL) i = SafeArrayUnaccessData(sa$amp_i) 
    end function
    function $IDiffraction_wavefront_get( pInterface ,&
             BeamID ,&
             amp_r ,&
             amp_i ) result (hresult)
        !DEC$ ATTRIBUTES STDCALL :: $IDiffraction_wavefront_get
        use Diffraction_Types
        use dfcom
        use dflib
        implicit none
        type (IDiffraction_Ptr) pInterface
        !dec$ attributes reference :: pInterface
        INTEGER(4), intent(in) :: BeamID 
        !DEC$ ATTRIBUTES value :: BeamID 
        integer(INT_PTR_KIND()), intent(inout) :: amp_r 
        !DEC$ ATTRIBUTES reference :: amp_r 
        integer(INT_PTR_KIND()), intent(inout) :: amp_i 
        !DEC$ ATTRIBUTES reference :: amp_i 
        integer(LONG) hresult
        integer i
        REAL(8) f$amp_r(:,:)
        volatile f$amp_r
        pointer f$amp_r
        integer(INT_PTR_KIND()) ptr$amp_r
        integer(INT_PTR_KIND()) sa$amp_r
        integer dims$amp_r
        integer lb$amp_r(2)
        integer ub$amp_r(2)
        integer nb$amp_r(2)
        type (FOR_DIMS_INFO) da$amp_r(2) 
        REAL(8) f$amp_i(:,:)
        volatile f$amp_i
        pointer f$amp_i
        integer(INT_PTR_KIND()) ptr$amp_i
        integer(INT_PTR_KIND()) sa$amp_i
        integer dims$amp_i
        integer lb$amp_i(2)
        integer ub$amp_i(2)
        integer nb$amp_i(2)
        type (FOR_DIMS_INFO) da$amp_i(2) 
        sa$amp_r = NULL
        lb$amp_r = 0
        ub$amp_r = 0
        nb$amp_r = 0 
        sa$amp_i = NULL
        lb$amp_i = 0
        ub$amp_i = 0
        nb$amp_i = 0 
        
        dims$amp_r = SafeArrayGetDim(amp_r)
        if (dims$amp_r /= 2) then
            hresult = E_INVALIDARG
            goto 9999
        end if
        do i = 1, 2
            hresult = SafeArrayGetLBound(amp_r, i, lb$amp_r(i))
            hresult = SafeArrayGetUBound(amp_r, i, ub$amp_r(i))
            nb$amp_r(i) = ub$amp_r(i) - lb$amp_r(i) + 1
        end do
        hresult = SafeArrayAccessData(amp_r, ptr$amp_r)
        if (hresult < 0) goto 9999
        sa$amp_r = amp_r
        da$amp_r(1)%LowerBound = lb$amp_r(1)
        da$amp_r(1)%UpperBound = ub$amp_r(1)
        da$amp_r(1)%Stride = 1
        da$amp_r(2)%LowerBound = lb$amp_r(2)
        da$amp_r(2)%UpperBound = ub$amp_r(2)
        da$amp_r(2)%Stride = 1
        call FOR_DESCRIPTOR_ASSIGN(f$amp_r, ptr$amp_r, SIZEOF(f$amp_r(lb$amp_r(1), lb$amp_r(2))), &
             IOR(FOR_DESCRIPTOR_ARRAY_DEFINED, IOR(FOR_DESCRIPTOR_ARRAY_NODEALLOC, FOR_DESCRIPTOR_ARRAY_CONTIGUOUS)), &
             2, da$amp_r) 
        
        dims$amp_i = SafeArrayGetDim(amp_i)
        if (dims$amp_i /= 2) then
            hresult = E_INVALIDARG
            goto 9999
        end if
        do i = 1, 2
            hresult = SafeArrayGetLBound(amp_i, i, lb$amp_i(i))
            hresult = SafeArrayGetUBound(amp_i, i, ub$amp_i(i))
            nb$amp_i(i) = ub$amp_i(i) - lb$amp_i(i) + 1
        end do
        hresult = SafeArrayAccessData(amp_i, ptr$amp_i)
        if (hresult < 0) goto 9999
        sa$amp_i = amp_i
        da$amp_i(1)%LowerBound = lb$amp_i(1)
        da$amp_i(1)%UpperBound = ub$amp_i(1)
        da$amp_i(1)%Stride = 1
        da$amp_i(2)%LowerBound = lb$amp_i(2)
        da$amp_i(2)%UpperBound = ub$amp_i(2)
        da$amp_i(2)%Stride = 1
        call FOR_DESCRIPTOR_ASSIGN(f$amp_i, ptr$amp_i, SIZEOF(f$amp_i(lb$amp_i(1), lb$amp_i(2))), &
             IOR(FOR_DESCRIPTOR_ARRAY_DEFINED, IOR(FOR_DESCRIPTOR_ARRAY_NODEALLOC, FOR_DESCRIPTOR_ARRAY_CONTIGUOUS)), &
             2, da$amp_i) 
		

        hresult = IDiffraction_wavefront_get(pInterface % pInternalData % pInstanceData ,&
             BeamID ,&
             f$amp_r ,&
             f$amp_i )
        
        if (hresult < 0) goto 9999
    9999  continue  ! Cleanup code
        
        if (sa$amp_r /= NULL) i = SafeArrayUnaccessData(sa$amp_r) 
        
        if (sa$amp_i /= NULL) i = SafeArrayUnaccessData(sa$amp_i) 
    end function
    function $IDiffraction_CopyWavefront( pInterface ,&
             BeamIDfrom ,&
             BeamIDto ,&
             status ) result (hresult)
        !DEC$ ATTRIBUTES STDCALL :: $IDiffraction_CopyWavefront
        use Diffraction_Types
        use dfcom
        use dflib
        implicit none
        type (IDiffraction_Ptr) pInterface
        !dec$ attributes reference :: pInterface
        INTEGER(4), intent(in) :: BeamIDfrom 
        !DEC$ ATTRIBUTES value :: BeamIDfrom 
        INTEGER(4), intent(in) :: BeamIDto 
        !DEC$ ATTRIBUTES value :: BeamIDto 
        INTEGER(4), intent(out) :: status 
        !DEC$ ATTRIBUTES reference :: status 
        integer(LONG) hresult
        integer i
		

        hresult = IDiffraction_CopyWavefront(pInterface % pInternalData % pInstanceData ,&
             BeamIDfrom ,&
             BeamIDto ,&
             status )
        
        if (hresult < 0) goto 9999
    9999  continue  ! Cleanup code
    end function
    function $IDiffraction_CopyWavefrontAmp( pInterface ,&
             BeamIDAmp ,&
             BeamIDPhase ,&
             status ) result (hresult)
        !DEC$ ATTRIBUTES STDCALL :: $IDiffraction_CopyWavefrontAmp
        use Diffraction_Types
        use dfcom
        use dflib
        implicit none
        type (IDiffraction_Ptr) pInterface
        !dec$ attributes reference :: pInterface
        INTEGER(4), intent(in) :: BeamIDAmp 
        !DEC$ ATTRIBUTES value :: BeamIDAmp 
        INTEGER(4), intent(in) :: BeamIDPhase 
        !DEC$ ATTRIBUTES value :: BeamIDPhase 
        INTEGER(4), intent(out) :: status 
        !DEC$ ATTRIBUTES reference :: status 
        integer(LONG) hresult
        integer i
		

        hresult = IDiffraction_CopyWavefrontAmp(pInterface % pInternalData % pInstanceData ,&
             BeamIDAmp ,&
             BeamIDPhase ,&
             status )
        
        if (hresult < 0) goto 9999
    9999  continue  ! Cleanup code
    end function
    function $IDiffraction_SumWavefront( pInterface ,&
             BeamID ,&
             BeamIDadd ,&
             status ) result (hresult)
        !DEC$ ATTRIBUTES STDCALL :: $IDiffraction_SumWavefront
        use Diffraction_Types
        use dfcom
        use dflib
        implicit none
        type (IDiffraction_Ptr) pInterface
        !dec$ attributes reference :: pInterface
        INTEGER(4), intent(in) :: BeamID 
        !DEC$ ATTRIBUTES value :: BeamID 
        INTEGER(4), intent(in) :: BeamIDadd 
        !DEC$ ATTRIBUTES value :: BeamIDadd 
        INTEGER(4), intent(out) :: status 
        !DEC$ ATTRIBUTES reference :: status 
        integer(LONG) hresult
        integer i
		

        hresult = IDiffraction_SumWavefront(pInterface % pInternalData % pInstanceData ,&
             BeamID ,&
             BeamIDadd ,&
             status )
        
        if (hresult < 0) goto 9999
    9999  continue  ! Cleanup code
    end function
    function $IDiffraction_GetWavefrontParms( pInterface ,&
             BeamID ,&
             Nx ,&
             Ny ,&
             dx ,&
             dy ,&
             curv ,&
             wavelength ) result (hresult)
        !DEC$ ATTRIBUTES STDCALL :: $IDiffraction_GetWavefrontParms
        use Diffraction_Types
        use dfcom
        use dflib
        implicit none
        type (IDiffraction_Ptr) pInterface
        !dec$ attributes reference :: pInterface
        INTEGER(4), intent(in) :: BeamID 
        !DEC$ ATTRIBUTES value :: BeamID 
        INTEGER(4), intent(out) :: Nx 
        !DEC$ ATTRIBUTES reference :: Nx 
        INTEGER(4), intent(out) :: Ny 
        !DEC$ ATTRIBUTES reference :: Ny 
        REAL(8), intent(out) :: dx 
        !DEC$ ATTRIBUTES reference :: dx 
        REAL(8), intent(out) :: dy 
        !DEC$ ATTRIBUTES reference :: dy 
        REAL(8), intent(out) :: curv 
        !DEC$ ATTRIBUTES reference :: curv 
        REAL(8), intent(out) :: wavelength 
        !DEC$ ATTRIBUTES reference :: wavelength 
        integer(LONG) hresult
        integer i
		

        hresult = IDiffraction_GetWavefrontParms(pInterface % pInternalData % pInstanceData ,&
             BeamID ,&
             Nx ,&
             Ny ,&
             dx ,&
             dy ,&
             curv ,&
             wavelength )
        
        if (hresult < 0) goto 9999
    9999  continue  ! Cleanup code
    end function
    function $IDiffraction_WriteWavefrontUNF( pInterface ,&
             StrFilename ,&
             BeamID ,&
             status ) result (hresult)
        !DEC$ ATTRIBUTES STDCALL :: $IDiffraction_WriteWavefrontUNF
        use Diffraction_Types
        use dfcom
        use dflib
        implicit none
        type (IDiffraction_Ptr) pInterface
        !dec$ attributes reference :: pInterface
        integer(INT_PTR_KIND()), intent(in) :: StrFilename 
        !DEC$ ATTRIBUTES value :: StrFilename 
        INTEGER(4), intent(in) :: BeamID 
        !DEC$ ATTRIBUTES value :: BeamID 
        INTEGER(4), intent(out) :: status 
        !DEC$ ATTRIBUTES reference :: status 
        integer(LONG) hresult
        integer i
        character(len=SysStringLen_Local(StrFilename)) f$StrFilename 
        
        i = ConvertBSTRToString(StrFilename, f$StrFilename) 
		

        hresult = IDiffraction_WriteWavefrontUNF(pInterface % pInternalData % pInstanceData ,&
             f$StrFilename ,&
             BeamID ,&
             status )
        
        if (hresult < 0) goto 9999
    9999  continue  ! Cleanup code
    end function
    function $IDiffraction_ReadWavefrontUNF( pInterface ,&
             StrFilename ,&
             BeamID ,&
             status ) result (hresult)
        !DEC$ ATTRIBUTES STDCALL :: $IDiffraction_ReadWavefrontUNF
        use Diffraction_Types
        use dfcom
        use dflib
        implicit none
        type (IDiffraction_Ptr) pInterface
        !dec$ attributes reference :: pInterface
        integer(INT_PTR_KIND()), intent(in) :: StrFilename 
        !DEC$ ATTRIBUTES value :: StrFilename 
        INTEGER(4), intent(in) :: BeamID 
        !DEC$ ATTRIBUTES value :: BeamID 
        INTEGER(4), intent(out) :: status 
        !DEC$ ATTRIBUTES reference :: status 
        integer(LONG) hresult
        integer i
        character(len=SysStringLen_Local(StrFilename)) f$StrFilename 
        
        i = ConvertBSTRToString(StrFilename, f$StrFilename) 
		

        hresult = IDiffraction_ReadWavefrontUNF(pInterface % pInternalData % pInstanceData ,&
             f$StrFilename ,&
             BeamID ,&
             status )
        
        if (hresult < 0) goto 9999
    9999  continue  ! Cleanup code
    end function
    function $IDiffraction_WavefrontPower( pInterface ,&
             power ,&
             BeamID ) result (hresult)
        !DEC$ ATTRIBUTES STDCALL :: $IDiffraction_WavefrontPower
        use Diffraction_Types
        use dfcom
        use dflib
        implicit none
        type (IDiffraction_Ptr) pInterface
        !dec$ attributes reference :: pInterface
        REAL(8), intent(out) :: power 
        !DEC$ ATTRIBUTES reference :: power 
        type(VARIANT), intent(in) :: BeamID 
        !DEC$ ATTRIBUTES value :: BeamID 
        integer(LONG) hresult
        integer i
        INTEGER(4) f$BeamID
        logical p$BeamID
        type(VARIANT) v$BeamID 
        p$BeamID = .FALSE. 
        if (.not.(BeamID%vt == VT_ERROR .and. &
            BeamID%vu%SCODE_VAL == DISP_E_PARAMNOTFOUND)) then
            p$BeamID = .TRUE.
            i = VariantChangeType(v$BeamID, BeamID, 0, VT_I4)
            if (i < 0) then
            hresult = DISP_E_TYPEMISMATCH
            goto 9999
        end if
            f$BeamID = v$BeamID%vu%LONG_VAL
        end if 
		
        if (p$BeamID == .FALSE.) then
            hresult = IDiffraction_WavefrontPower(pInterface % pInternalData % pInstanceData, &
                power)
        else
        hresult = IDiffraction_WavefrontPower(pInterface % pInternalData % pInstanceData ,&
             power ,&
             f$BeamID )
        end if
        if (hresult < 0) goto 9999
    9999  continue  ! Cleanup code
    end function
    function $IDiffraction_ApplyMask( pInterface ,&
             length_r ,&
             length_t ,&
             offset ,&
             direction ) result (hresult)
        !DEC$ ATTRIBUTES STDCALL :: $IDiffraction_ApplyMask
        use Diffraction_Types
        use dfcom
        use dflib
        implicit none
        type (IDiffraction_Ptr) pInterface
        !dec$ attributes reference :: pInterface
        REAL(8), intent(in) :: length_r 
        !DEC$ ATTRIBUTES value :: length_r 
        REAL(8), intent(in) :: length_t 
        !DEC$ ATTRIBUTES value :: length_t 
        REAL(8), intent(in) :: offset 
        !DEC$ ATTRIBUTES value :: offset 
        integer(INT_PTR_KIND()), intent(in) :: direction 
        !DEC$ ATTRIBUTES value :: direction 
        integer(LONG) hresult
        integer i
        character(len=SysStringLen_Local(direction)) f$direction 
        
        i = ConvertBSTRToString(direction, f$direction) 
		

        hresult = IDiffraction_ApplyMask(pInterface % pInternalData % pInstanceData ,&
             length_r ,&
             length_t ,&
             offset ,&
             f$direction )
        
        if (hresult < 0) goto 9999
    9999  continue  ! Cleanup code
    end function
    function $IDiffraction_ApplyMaskMisalign( pInterface ,&
             length_r ,&
             length_t ,&
             offset ,&
             xc ,&
             yc ,&
             direction ) result (hresult)
        !DEC$ ATTRIBUTES STDCALL :: $IDiffraction_ApplyMaskMisalign
        use Diffraction_Types
        use dfcom
        use dflib
        implicit none
        type (IDiffraction_Ptr) pInterface
        !dec$ attributes reference :: pInterface
        REAL(8), intent(in) :: length_r 
        !DEC$ ATTRIBUTES value :: length_r 
        REAL(8), intent(in) :: length_t 
        !DEC$ ATTRIBUTES value :: length_t 
        REAL(8), intent(in) :: offset 
        !DEC$ ATTRIBUTES value :: offset 
        REAL(8), intent(in) :: xc 
        !DEC$ ATTRIBUTES value :: xc 
        REAL(8), intent(in) :: yc 
        !DEC$ ATTRIBUTES value :: yc 
        integer(INT_PTR_KIND()), intent(in) :: direction 
        !DEC$ ATTRIBUTES value :: direction 
        integer(LONG) hresult
        integer i
        character(len=SysStringLen_Local(direction)) f$direction 
        
        i = ConvertBSTRToString(direction, f$direction) 
		

        hresult = IDiffraction_ApplyMaskMisalign(pInterface % pInternalData % pInstanceData ,&
             length_r ,&
             length_t ,&
             offset ,&
             xc ,&
             yc ,&
             f$direction )
        
        if (hresult < 0) goto 9999
    9999  continue  ! Cleanup code
    end function
    function $IDiffraction_ApplyMaskGeneral( pInterface ,&
             len_x ,&
             len_y ,&
             off_x ,&
             off_y ) result (hresult)
        !DEC$ ATTRIBUTES STDCALL :: $IDiffraction_ApplyMaskGeneral
        use Diffraction_Types
        use dfcom
        use dflib
        implicit none
        type (IDiffraction_Ptr) pInterface
        !dec$ attributes reference :: pInterface
        REAL(8), intent(in) :: len_x 
        !DEC$ ATTRIBUTES value :: len_x 
        REAL(8), intent(in) :: len_y 
        !DEC$ ATTRIBUTES value :: len_y 
        REAL(8), intent(in) :: off_x 
        !DEC$ ATTRIBUTES value :: off_x 
        REAL(8), intent(in) :: off_y 
        !DEC$ ATTRIBUTES value :: off_y 
        integer(LONG) hresult
        integer i
		

        hresult = IDiffraction_ApplyMaskGeneral(pInterface % pInternalData % pInstanceData ,&
             len_x ,&
             len_y ,&
             off_x ,&
             off_y )
        
        if (hresult < 0) goto 9999
    9999  continue  ! Cleanup code
    end function
    function $IDiffraction_ApplyMaskPoly( pInterface ,&
             vertices ,&
             xc ,&
             yc ) result (hresult)
        !DEC$ ATTRIBUTES STDCALL :: $IDiffraction_ApplyMaskPoly
        use Diffraction_Types
        use dfcom
        use dflib
        implicit none
        type (IDiffraction_Ptr) pInterface
        !dec$ attributes reference :: pInterface
        integer(INT_PTR_KIND()), intent(in) :: vertices 
        !DEC$ ATTRIBUTES value :: vertices 
        REAL(8), intent(in) :: xc 
        !DEC$ ATTRIBUTES value :: xc 
        REAL(8), intent(in) :: yc 
        !DEC$ ATTRIBUTES value :: yc 
        integer(LONG) hresult
        integer i
        REAL(8) f$vertices(:,:)
        volatile f$vertices
        pointer f$vertices
        integer(INT_PTR_KIND()) ptr$vertices
        integer(INT_PTR_KIND()) sa$vertices
        integer dims$vertices
        integer lb$vertices(2)
        integer ub$vertices(2)
        integer nb$vertices(2)
        type (FOR_DIMS_INFO) da$vertices(2) 
        sa$vertices = NULL
        lb$vertices = 0
        ub$vertices = 0
        nb$vertices = 0 
        
        dims$vertices = SafeArrayGetDim(vertices)
        if (dims$vertices /= 2) then
            hresult = E_INVALIDARG
            goto 9999
        end if
        do i = 1, 2
            hresult = SafeArrayGetLBound(vertices, i, lb$vertices(i))
            hresult = SafeArrayGetUBound(vertices, i, ub$vertices(i))
            nb$vertices(i) = ub$vertices(i) - lb$vertices(i) + 1
        end do
        hresult = SafeArrayAccessData(vertices, ptr$vertices)
        if (hresult < 0) goto 9999
        sa$vertices = vertices
        da$vertices(1)%LowerBound = lb$vertices(1)
        da$vertices(1)%UpperBound = ub$vertices(1)
        da$vertices(1)%Stride = 1
        da$vertices(2)%LowerBound = lb$vertices(2)
        da$vertices(2)%UpperBound = ub$vertices(2)
        da$vertices(2)%Stride = 1
        call FOR_DESCRIPTOR_ASSIGN(f$vertices, ptr$vertices, SIZEOF(f$vertices(lb$vertices(1), lb$vertices(2))), &
             IOR(FOR_DESCRIPTOR_ARRAY_DEFINED, IOR(FOR_DESCRIPTOR_ARRAY_NODEALLOC, FOR_DESCRIPTOR_ARRAY_CONTIGUOUS)), &
             2, da$vertices) 
		

        hresult = IDiffraction_ApplyMaskPoly(pInterface % pInternalData % pInstanceData ,&
             f$vertices ,&
             xc ,&
             yc )
        
        if (hresult < 0) goto 9999
    9999  continue  ! Cleanup code
        
        if (sa$vertices /= NULL) i = SafeArrayUnaccessData(sa$vertices) 
    end function
    function $IDiffraction_ApplyMaskX( pInterface ,&
             radius ,&
             length ) result (hresult)
        !DEC$ ATTRIBUTES STDCALL :: $IDiffraction_ApplyMaskX
        use Diffraction_Types
        use dfcom
        use dflib
        implicit none
        type (IDiffraction_Ptr) pInterface
        !dec$ attributes reference :: pInterface
        REAL(8), intent(in) :: radius 
        !DEC$ ATTRIBUTES value :: radius 
        REAL(8), intent(in) :: length 
        !DEC$ ATTRIBUTES value :: length 
        integer(LONG) hresult
        integer i
		

        hresult = IDiffraction_ApplyMaskX(pInterface % pInternalData % pInstanceData ,&
             radius ,&
             length )
        
        if (hresult < 0) goto 9999
    9999  continue  ! Cleanup code
    end function
    function $IDiffraction_ApplyMaskXRounded( pInterface ,&
             radius ,&
             length ,&
             corner_rad ) result (hresult)
        !DEC$ ATTRIBUTES STDCALL :: $IDiffraction_ApplyMaskXRounded
        use Diffraction_Types
        use dfcom
        use dflib
        implicit none
        type (IDiffraction_Ptr) pInterface
        !dec$ attributes reference :: pInterface
        REAL(8), intent(in) :: radius 
        !DEC$ ATTRIBUTES value :: radius 
        REAL(8), intent(in) :: length 
        !DEC$ ATTRIBUTES value :: length 
        REAL(8), intent(in) :: corner_rad 
        !DEC$ ATTRIBUTES value :: corner_rad 
        integer(LONG) hresult
        integer i
		

        hresult = IDiffraction_ApplyMaskXRounded(pInterface % pInternalData % pInstanceData ,&
             radius ,&
             length ,&
             corner_rad )
        
        if (hresult < 0) goto 9999
    9999  continue  ! Cleanup code
    end function
    function $IDiffraction_ApplyMaskRotate( pInterface ,&
             length_r ,&
             length_t ,&
             offset ,&
             angle ,&
             xc ,&
             yc ,&
             direction ,&
             BeamID ,&
             status ) result (hresult)
        !DEC$ ATTRIBUTES STDCALL :: $IDiffraction_ApplyMaskRotate
        use Diffraction_Types
        use dfcom
        use dflib
        implicit none
        type (IDiffraction_Ptr) pInterface
        !dec$ attributes reference :: pInterface
        REAL(8), intent(in) :: length_r 
        !DEC$ ATTRIBUTES value :: length_r 
        REAL(8), intent(in) :: length_t 
        !DEC$ ATTRIBUTES value :: length_t 
        REAL(8), intent(in) :: offset 
        !DEC$ ATTRIBUTES value :: offset 
        REAL(8), intent(in) :: angle 
        !DEC$ ATTRIBUTES value :: angle 
        REAL(8), intent(in) :: xc 
        !DEC$ ATTRIBUTES value :: xc 
        REAL(8), intent(in) :: yc 
        !DEC$ ATTRIBUTES value :: yc 
        integer(INT_PTR_KIND()), intent(in) :: direction 
        !DEC$ ATTRIBUTES value :: direction 
        INTEGER(4), intent(in) :: BeamID 
        !DEC$ ATTRIBUTES value :: BeamID 
        INTEGER(4), intent(out) :: status 
        !DEC$ ATTRIBUTES reference :: status 
        integer(LONG) hresult
        integer i
        character(len=SysStringLen_Local(direction)) f$direction 
        
        i = ConvertBSTRToString(direction, f$direction) 
		

        hresult = IDiffraction_ApplyMaskRotate(pInterface % pInternalData % pInstanceData ,&
             length_r ,&
             length_t ,&
             offset ,&
             angle ,&
             xc ,&
             yc ,&
             f$direction ,&
             BeamID ,&
             status )
        
        if (hresult < 0) goto 9999
    9999  continue  ! Cleanup code
    end function
    function $IDiffraction_ApplyMaskTilt( pInterface ,&
             length_r ,&
             length_t ,&
             offset ,&
             rotangle ,&
             xc ,&
             yc ,&
             tiltangle ,&
             tiltorientation ,&
             direction ,&
             BeamID ,&
             status ) result (hresult)
        !DEC$ ATTRIBUTES STDCALL :: $IDiffraction_ApplyMaskTilt
        use Diffraction_Types
        use dfcom
        use dflib
        implicit none
        type (IDiffraction_Ptr) pInterface
        !dec$ attributes reference :: pInterface
        REAL(8), intent(in) :: length_r 
        !DEC$ ATTRIBUTES value :: length_r 
        REAL(8), intent(in) :: length_t 
        !DEC$ ATTRIBUTES value :: length_t 
        REAL(8), intent(in) :: offset 
        !DEC$ ATTRIBUTES value :: offset 
        REAL(8), intent(in) :: rotangle 
        !DEC$ ATTRIBUTES value :: rotangle 
        REAL(8), intent(in) :: xc 
        !DEC$ ATTRIBUTES value :: xc 
        REAL(8), intent(in) :: yc 
        !DEC$ ATTRIBUTES value :: yc 
        REAL(8), intent(in) :: tiltangle 
        !DEC$ ATTRIBUTES value :: tiltangle 
        REAL(8), intent(in) :: tiltorientation 
        !DEC$ ATTRIBUTES value :: tiltorientation 
        integer(INT_PTR_KIND()), intent(in) :: direction 
        !DEC$ ATTRIBUTES value :: direction 
        INTEGER(4), intent(in) :: BeamID 
        !DEC$ ATTRIBUTES value :: BeamID 
        INTEGER(4), intent(out) :: status 
        !DEC$ ATTRIBUTES reference :: status 
        integer(LONG) hresult
        integer i
        character(len=SysStringLen_Local(direction)) f$direction 
        
        i = ConvertBSTRToString(direction, f$direction) 
		

        hresult = IDiffraction_ApplyMaskTilt(pInterface % pInternalData % pInstanceData ,&
             length_r ,&
             length_t ,&
             offset ,&
             rotangle ,&
             xc ,&
             yc ,&
             tiltangle ,&
             tiltorientation ,&
             f$direction ,&
             BeamID ,&
             status )
        
        if (hresult < 0) goto 9999
    9999  continue  ! Cleanup code
    end function
    function $IDiffraction_CreateGausSource( pInterface ,&
             BeamWaistDiam ,&
             Nx ,&
             Ny ,&
             dx ,&
             dy ,&
             wavelength ,&
             BeamID ,&
             status ) result (hresult)
        !DEC$ ATTRIBUTES STDCALL :: $IDiffraction_CreateGausSource
        use Diffraction_Types
        use dfcom
        use dflib
        implicit none
        type (IDiffraction_Ptr) pInterface
        !dec$ attributes reference :: pInterface
        REAL(8), intent(in) :: BeamWaistDiam 
        !DEC$ ATTRIBUTES value :: BeamWaistDiam 
        INTEGER(4), intent(in) :: Nx 
        !DEC$ ATTRIBUTES value :: Nx 
        INTEGER(4), intent(in) :: Ny 
        !DEC$ ATTRIBUTES value :: Ny 
        REAL(8), intent(in) :: dx 
        !DEC$ ATTRIBUTES value :: dx 
        REAL(8), intent(in) :: dy 
        !DEC$ ATTRIBUTES value :: dy 
        REAL(8), intent(in) :: wavelength 
        !DEC$ ATTRIBUTES value :: wavelength 
        INTEGER(4), intent(in) :: BeamID 
        !DEC$ ATTRIBUTES value :: BeamID 
        INTEGER(4), intent(out) :: status 
        !DEC$ ATTRIBUTES reference :: status 
        integer(LONG) hresult
        integer i
		

        hresult = IDiffraction_CreateGausSource(pInterface % pInternalData % pInstanceData ,&
             BeamWaistDiam ,&
             Nx ,&
             Ny ,&
             dx ,&
             dy ,&
             wavelength ,&
             BeamID ,&
             status )
        
        if (hresult < 0) goto 9999
    9999  continue  ! Cleanup code
    end function
    function $IDiffraction_CreateTophatSource( pInterface ,&
             BeamDiam ,&
             Nx ,&
             Ny ,&
             dx ,&
             dy ,&
             wavelength ,&
             BeamID ,&
             status ) result (hresult)
        !DEC$ ATTRIBUTES STDCALL :: $IDiffraction_CreateTophatSource
        use Diffraction_Types
        use dfcom
        use dflib
        implicit none
        type (IDiffraction_Ptr) pInterface
        !dec$ attributes reference :: pInterface
        REAL(8), intent(in) :: BeamDiam 
        !DEC$ ATTRIBUTES value :: BeamDiam 
        INTEGER(4), intent(in) :: Nx 
        !DEC$ ATTRIBUTES value :: Nx 
        INTEGER(4), intent(in) :: Ny 
        !DEC$ ATTRIBUTES value :: Ny 
        REAL(8), intent(in) :: dx 
        !DEC$ ATTRIBUTES value :: dx 
        REAL(8), intent(in) :: dy 
        !DEC$ ATTRIBUTES value :: dy 
        REAL(8), intent(in) :: wavelength 
        !DEC$ ATTRIBUTES value :: wavelength 
        INTEGER(4), intent(in) :: BeamID 
        !DEC$ ATTRIBUTES value :: BeamID 
        INTEGER(4), intent(out) :: status 
        !DEC$ ATTRIBUTES reference :: status 
        integer(LONG) hresult
        integer i
		

        hresult = IDiffraction_CreateTophatSource(pInterface % pInternalData % pInstanceData ,&
             BeamDiam ,&
             Nx ,&
             Ny ,&
             dx ,&
             dy ,&
             wavelength ,&
             BeamID ,&
             status )
        
        if (hresult < 0) goto 9999
    9999  continue  ! Cleanup code
    end function
    function $IDiffraction_Propagate( pInterface ,&
             Distance ,&
             BeamID ) result (hresult)
        !DEC$ ATTRIBUTES STDCALL :: $IDiffraction_Propagate
        use Diffraction_Types
        use dfcom
        use dflib
        implicit none
        type (IDiffraction_Ptr) pInterface
        !dec$ attributes reference :: pInterface
        REAL(8), intent(in) :: Distance 
        !DEC$ ATTRIBUTES value :: Distance 
        INTEGER(4), intent(in) :: BeamID 
        !DEC$ ATTRIBUTES value :: BeamID 
        integer(LONG) hresult
        integer i
		

        hresult = IDiffraction_Propagate(pInterface % pInternalData % pInstanceData ,&
             Distance ,&
             BeamID )
        
        if (hresult < 0) goto 9999
    9999  continue  ! Cleanup code
    end function
    function $IDiffraction_PropagateExt( pInterface ,&
             Distance ,&
             dxout ,&
             dyout ,&
             applyCurv ,&
             BeamID ,&
             status ) result (hresult)
        !DEC$ ATTRIBUTES STDCALL :: $IDiffraction_PropagateExt
        use Diffraction_Types
        use dfcom
        use dflib
        implicit none
        type (IDiffraction_Ptr) pInterface
        !dec$ attributes reference :: pInterface
        REAL(8), intent(in) :: Distance 
        !DEC$ ATTRIBUTES value :: Distance 
        REAL(8), intent(in) :: dxout 
        !DEC$ ATTRIBUTES value :: dxout 
        REAL(8), intent(in) :: dyout 
        !DEC$ ATTRIBUTES value :: dyout 
        LOGICAL(4), intent(in) :: applyCurv 
        !DEC$ ATTRIBUTES value :: applyCurv 
        INTEGER(4), intent(in) :: BeamID 
        !DEC$ ATTRIBUTES value :: BeamID 
        INTEGER(4), intent(out) :: status 
        !DEC$ ATTRIBUTES reference :: status 
        integer(LONG) hresult
        integer i
		

        hresult = IDiffraction_PropagateExt(pInterface % pInternalData % pInstanceData ,&
             Distance ,&
             dxout ,&
             dyout ,&
             applyCurv ,&
             BeamID ,&
             status )
        
        if (hresult < 0) goto 9999
    9999  continue  ! Cleanup code
    end function
    function $IDiffraction_PropagateDefDx( pInterface ,&
             Distance ) result (hresult)
        !DEC$ ATTRIBUTES STDCALL :: $IDiffraction_PropagateDefDx
        use Diffraction_Types
        use dfcom
        use dflib
        implicit none
        type (IDiffraction_Ptr) pInterface
        !dec$ attributes reference :: pInterface
        REAL(8), intent(in) :: Distance 
        !DEC$ ATTRIBUTES value :: Distance 
        integer(LONG) hresult
        integer i
		

        hresult = IDiffraction_PropagateDefDx(pInterface % pInternalData % pInstanceData ,&
             Distance )
        
        if (hresult < 0) goto 9999
    9999  continue  ! Cleanup code
    end function
    function $IDiffraction_CornerCube( pInterface ,&
             ccsize ,&
             shape ,&
             xc ,&
             yc ,&
             spin ,&
             gapwidth ,&
             rotmatrix ,&
             dihedral ,&
             edgelength ) result (hresult)
        !DEC$ ATTRIBUTES STDCALL :: $IDiffraction_CornerCube
        use Diffraction_Types
        use dfcom
        use dflib
        implicit none
        type (IDiffraction_Ptr) pInterface
        !dec$ attributes reference :: pInterface
        REAL(8), intent(in) :: ccsize 
        !DEC$ ATTRIBUTES value :: ccsize 
        integer(INT_PTR_KIND()), intent(in) :: shape 
        !DEC$ ATTRIBUTES value :: shape 
        REAL(8), intent(in) :: xc 
        !DEC$ ATTRIBUTES value :: xc 
        REAL(8), intent(in) :: yc 
        !DEC$ ATTRIBUTES value :: yc 
        REAL(8), intent(in) :: spin 
        !DEC$ ATTRIBUTES value :: spin 
        integer(INT_PTR_KIND()), intent(in) :: gapwidth 
        !DEC$ ATTRIBUTES value :: gapwidth 
        integer(INT_PTR_KIND()), intent(in) :: rotmatrix 
        !DEC$ ATTRIBUTES value :: rotmatrix 
        integer(INT_PTR_KIND()), intent(in) :: dihedral 
        !DEC$ ATTRIBUTES value :: dihedral 
        integer(INT_PTR_KIND()), intent(in) :: edgelength 
        !DEC$ ATTRIBUTES value :: edgelength 
        integer(LONG) hresult
        integer i
        character(len=SysStringLen_Local(shape)) f$shape 
        REAL(8) f$gapwidth(:,:)
        volatile f$gapwidth
        pointer f$gapwidth
        integer(INT_PTR_KIND()) ptr$gapwidth
        integer(INT_PTR_KIND()) sa$gapwidth
        integer dims$gapwidth
        integer lb$gapwidth(2)
        integer ub$gapwidth(2)
        integer nb$gapwidth(2)
        type (FOR_DIMS_INFO) da$gapwidth(2) 
        REAL(8) f$rotmatrix(:,:)
        volatile f$rotmatrix
        pointer f$rotmatrix
        integer(INT_PTR_KIND()) ptr$rotmatrix
        integer(INT_PTR_KIND()) sa$rotmatrix
        integer dims$rotmatrix
        integer lb$rotmatrix(2)
        integer ub$rotmatrix(2)
        integer nb$rotmatrix(2)
        type (FOR_DIMS_INFO) da$rotmatrix(2) 
        REAL(8) f$dihedral(:,:)
        volatile f$dihedral
        pointer f$dihedral
        integer(INT_PTR_KIND()) ptr$dihedral
        integer(INT_PTR_KIND()) sa$dihedral
        integer dims$dihedral
        integer lb$dihedral(2)
        integer ub$dihedral(2)
        integer nb$dihedral(2)
        type (FOR_DIMS_INFO) da$dihedral(2) 
        REAL(8) f$edgelength(:,:)
        volatile f$edgelength
        pointer f$edgelength
        integer(INT_PTR_KIND()) ptr$edgelength
        integer(INT_PTR_KIND()) sa$edgelength
        integer dims$edgelength
        integer lb$edgelength(2)
        integer ub$edgelength(2)
        integer nb$edgelength(2)
        type (FOR_DIMS_INFO) da$edgelength(2) 
        sa$gapwidth = NULL
        lb$gapwidth = 0
        ub$gapwidth = 0
        nb$gapwidth = 0 
        sa$rotmatrix = NULL
        lb$rotmatrix = 0
        ub$rotmatrix = 0
        nb$rotmatrix = 0 
        sa$dihedral = NULL
        lb$dihedral = 0
        ub$dihedral = 0
        nb$dihedral = 0 
        sa$edgelength = NULL
        lb$edgelength = 0
        ub$edgelength = 0
        nb$edgelength = 0 
        
        i = ConvertBSTRToString(shape, f$shape) 
        
        dims$gapwidth = SafeArrayGetDim(gapwidth)
        if (dims$gapwidth /= 2) then
            hresult = E_INVALIDARG
            goto 9999
        end if
        do i = 1, 2
            hresult = SafeArrayGetLBound(gapwidth, i, lb$gapwidth(i))
            hresult = SafeArrayGetUBound(gapwidth, i, ub$gapwidth(i))
            nb$gapwidth(i) = ub$gapwidth(i) - lb$gapwidth(i) + 1
        end do
        hresult = SafeArrayAccessData(gapwidth, ptr$gapwidth)
        if (hresult < 0) goto 9999
        sa$gapwidth = gapwidth
        da$gapwidth(1)%LowerBound = lb$gapwidth(1)
        da$gapwidth(1)%UpperBound = ub$gapwidth(1)
        da$gapwidth(1)%Stride = 1
        da$gapwidth(2)%LowerBound = lb$gapwidth(2)
        da$gapwidth(2)%UpperBound = ub$gapwidth(2)
        da$gapwidth(2)%Stride = 1
        call FOR_DESCRIPTOR_ASSIGN(f$gapwidth, ptr$gapwidth, SIZEOF(f$gapwidth(lb$gapwidth(1), lb$gapwidth(2))), &
             IOR(FOR_DESCRIPTOR_ARRAY_DEFINED, IOR(FOR_DESCRIPTOR_ARRAY_NODEALLOC, FOR_DESCRIPTOR_ARRAY_CONTIGUOUS)), &
             2, da$gapwidth) 
        
        dims$rotmatrix = SafeArrayGetDim(rotmatrix)
        if (dims$rotmatrix /= 2) then
            hresult = E_INVALIDARG
            goto 9999
        end if
        do i = 1, 2
            hresult = SafeArrayGetLBound(rotmatrix, i, lb$rotmatrix(i))
            hresult = SafeArrayGetUBound(rotmatrix, i, ub$rotmatrix(i))
            nb$rotmatrix(i) = ub$rotmatrix(i) - lb$rotmatrix(i) + 1
        end do
        hresult = SafeArrayAccessData(rotmatrix, ptr$rotmatrix)
        if (hresult < 0) goto 9999
        sa$rotmatrix = rotmatrix
        da$rotmatrix(1)%LowerBound = lb$rotmatrix(1)
        da$rotmatrix(1)%UpperBound = ub$rotmatrix(1)
        da$rotmatrix(1)%Stride = 1
        da$rotmatrix(2)%LowerBound = lb$rotmatrix(2)
        da$rotmatrix(2)%UpperBound = ub$rotmatrix(2)
        da$rotmatrix(2)%Stride = 1
        call FOR_DESCRIPTOR_ASSIGN(f$rotmatrix, ptr$rotmatrix, SIZEOF(f$rotmatrix(lb$rotmatrix(1), lb$rotmatrix(2))), &
             IOR(FOR_DESCRIPTOR_ARRAY_DEFINED, IOR(FOR_DESCRIPTOR_ARRAY_NODEALLOC, FOR_DESCRIPTOR_ARRAY_CONTIGUOUS)), &
             2, da$rotmatrix) 
        
        dims$dihedral = SafeArrayGetDim(dihedral)
        if (dims$dihedral /= 2) then
            hresult = E_INVALIDARG
            goto 9999
        end if
        do i = 1, 2
            hresult = SafeArrayGetLBound(dihedral, i, lb$dihedral(i))
            hresult = SafeArrayGetUBound(dihedral, i, ub$dihedral(i))
            nb$dihedral(i) = ub$dihedral(i) - lb$dihedral(i) + 1
        end do
        hresult = SafeArrayAccessData(dihedral, ptr$dihedral)
        if (hresult < 0) goto 9999
        sa$dihedral = dihedral
        da$dihedral(1)%LowerBound = lb$dihedral(1)
        da$dihedral(1)%UpperBound = ub$dihedral(1)
        da$dihedral(1)%Stride = 1
        da$dihedral(2)%LowerBound = lb$dihedral(2)
        da$dihedral(2)%UpperBound = ub$dihedral(2)
        da$dihedral(2)%Stride = 1
        call FOR_DESCRIPTOR_ASSIGN(f$dihedral, ptr$dihedral, SIZEOF(f$dihedral(lb$dihedral(1), lb$dihedral(2))), &
             IOR(FOR_DESCRIPTOR_ARRAY_DEFINED, IOR(FOR_DESCRIPTOR_ARRAY_NODEALLOC, FOR_DESCRIPTOR_ARRAY_CONTIGUOUS)), &
             2, da$dihedral) 
        
        dims$edgelength = SafeArrayGetDim(edgelength)
        if (dims$edgelength /= 2) then
            hresult = E_INVALIDARG
            goto 9999
        end if
        do i = 1, 2
            hresult = SafeArrayGetLBound(edgelength, i, lb$edgelength(i))
            hresult = SafeArrayGetUBound(edgelength, i, ub$edgelength(i))
            nb$edgelength(i) = ub$edgelength(i) - lb$edgelength(i) + 1
        end do
        hresult = SafeArrayAccessData(edgelength, ptr$edgelength)
        if (hresult < 0) goto 9999
        sa$edgelength = edgelength
        da$edgelength(1)%LowerBound = lb$edgelength(1)
        da$edgelength(1)%UpperBound = ub$edgelength(1)
        da$edgelength(1)%Stride = 1
        da$edgelength(2)%LowerBound = lb$edgelength(2)
        da$edgelength(2)%UpperBound = ub$edgelength(2)
        da$edgelength(2)%Stride = 1
        call FOR_DESCRIPTOR_ASSIGN(f$edgelength, ptr$edgelength, SIZEOF(f$edgelength(lb$edgelength(1), lb$edgelength(2))), &
             IOR(FOR_DESCRIPTOR_ARRAY_DEFINED, IOR(FOR_DESCRIPTOR_ARRAY_NODEALLOC, FOR_DESCRIPTOR_ARRAY_CONTIGUOUS)), &
             2, da$edgelength) 
		

        hresult = IDiffraction_CornerCube(pInterface % pInternalData % pInstanceData ,&
             ccsize ,&
             f$shape ,&
             xc ,&
             yc ,&
             spin ,&
             f$gapwidth ,&
             f$rotmatrix ,&
             f$dihedral ,&
             f$edgelength )
        
        if (hresult < 0) goto 9999
    9999  continue  ! Cleanup code
        
        if (sa$gapwidth /= NULL) i = SafeArrayUnaccessData(sa$gapwidth) 
        
        if (sa$rotmatrix /= NULL) i = SafeArrayUnaccessData(sa$rotmatrix) 
        
        if (sa$dihedral /= NULL) i = SafeArrayUnaccessData(sa$dihedral) 
        
        if (sa$edgelength /= NULL) i = SafeArrayUnaccessData(sa$edgelength) 
    end function
    function $IDiffraction_focuslens( pInterface ,&
             focuslens_f ,&
             focuslens_D ,&
             dxout ,&
             dyout ,&
             BeamID ,&
             status ) result (hresult)
        !DEC$ ATTRIBUTES STDCALL :: $IDiffraction_focuslens
        use Diffraction_Types
        use dfcom
        use dflib
        implicit none
        type (IDiffraction_Ptr) pInterface
        !dec$ attributes reference :: pInterface
        REAL(8), intent(in) :: focuslens_f 
        !DEC$ ATTRIBUTES value :: focuslens_f 
        REAL(8), intent(in) :: focuslens_D 
        !DEC$ ATTRIBUTES value :: focuslens_D 
        REAL(8), intent(in) :: dxout 
        !DEC$ ATTRIBUTES value :: dxout 
        REAL(8), intent(in) :: dyout 
        !DEC$ ATTRIBUTES value :: dyout 
        INTEGER(4), intent(in) :: BeamID 
        !DEC$ ATTRIBUTES value :: BeamID 
        INTEGER(4), intent(out) :: status 
        !DEC$ ATTRIBUTES reference :: status 
        integer(LONG) hresult
        integer i
		

        hresult = IDiffraction_focuslens(pInterface % pInternalData % pInstanceData ,&
             focuslens_f ,&
             focuslens_D ,&
             dxout ,&
             dyout ,&
             BeamID ,&
             status )
        
        if (hresult < 0) goto 9999
    9999  continue  ! Cleanup code
    end function
    function $IDiffraction_ThinLens( pInterface ,&
             focallength ,&
             diameter ,&
             xc ,&
             yc ,&
             BeamID ,&
             status ) result (hresult)
        !DEC$ ATTRIBUTES STDCALL :: $IDiffraction_ThinLens
        use Diffraction_Types
        use dfcom
        use dflib
        implicit none
        type (IDiffraction_Ptr) pInterface
        !dec$ attributes reference :: pInterface
        REAL(8), intent(in) :: focallength 
        !DEC$ ATTRIBUTES value :: focallength 
        REAL(8), intent(in) :: diameter 
        !DEC$ ATTRIBUTES value :: diameter 
        REAL(8), intent(in) :: xc 
        !DEC$ ATTRIBUTES value :: xc 
        REAL(8), intent(in) :: yc 
        !DEC$ ATTRIBUTES value :: yc 
        INTEGER(4), intent(in) :: BeamID 
        !DEC$ ATTRIBUTES value :: BeamID 
        INTEGER(4), intent(out) :: status 
        !DEC$ ATTRIBUTES reference :: status 
        integer(LONG) hresult
        integer i
		

        hresult = IDiffraction_ThinLens(pInterface % pInternalData % pInstanceData ,&
             focallength ,&
             diameter ,&
             xc ,&
             yc ,&
             BeamID ,&
             status )
        
        if (hresult < 0) goto 9999
    9999  continue  ! Cleanup code
    end function
    function $IDiffraction_ReflectAsphere( pInterface ,&
             rCurv ,&
             conicConst ,&
             diam ,&
             xDecenter ,&
             yDecenter ,&
             incidenceAngle ,&
             azimuth ,&
             applyCurv ) result (hresult)
        !DEC$ ATTRIBUTES STDCALL :: $IDiffraction_ReflectAsphere
        use Diffraction_Types
        use dfcom
        use dflib
        implicit none
        type (IDiffraction_Ptr) pInterface
        !dec$ attributes reference :: pInterface
        REAL(8), intent(in) :: rCurv 
        !DEC$ ATTRIBUTES value :: rCurv 
        REAL(8), intent(in) :: conicConst 
        !DEC$ ATTRIBUTES value :: conicConst 
        REAL(8), intent(in) :: diam 
        !DEC$ ATTRIBUTES value :: diam 
        REAL(8), intent(in) :: xDecenter 
        !DEC$ ATTRIBUTES value :: xDecenter 
        REAL(8), intent(in) :: yDecenter 
        !DEC$ ATTRIBUTES value :: yDecenter 
        REAL(8), intent(in) :: incidenceAngle 
        !DEC$ ATTRIBUTES value :: incidenceAngle 
        REAL(8), intent(in) :: azimuth 
        !DEC$ ATTRIBUTES value :: azimuth 
        INTEGER(4), intent(in) :: applyCurv 
        !DEC$ ATTRIBUTES value :: applyCurv 
        integer(LONG) hresult
        integer i
		

        hresult = IDiffraction_ReflectAsphere(pInterface % pInternalData % pInstanceData ,&
             rCurv ,&
             conicConst ,&
             diam ,&
             xDecenter ,&
             yDecenter ,&
             incidenceAngle ,&
             azimuth ,&
             applyCurv )
        
        if (hresult < 0) goto 9999
    9999  continue  ! Cleanup code
    end function
    function $IDiffraction_PistonTiltFocus( pInterface ,&
             piston ,&
             xtilt ,&
             ytilt ,&
             focus ,&
             xc ,&
             yc ) result (hresult)
        !DEC$ ATTRIBUTES STDCALL :: $IDiffraction_PistonTiltFocus
        use Diffraction_Types
        use dfcom
        use dflib
        implicit none
        type (IDiffraction_Ptr) pInterface
        !dec$ attributes reference :: pInterface
        REAL(8), intent(in) :: piston 
        !DEC$ ATTRIBUTES value :: piston 
        REAL(8), intent(in) :: xtilt 
        !DEC$ ATTRIBUTES value :: xtilt 
        REAL(8), intent(in) :: ytilt 
        !DEC$ ATTRIBUTES value :: ytilt 
        REAL(8), intent(in) :: focus 
        !DEC$ ATTRIBUTES value :: focus 
        REAL(8), intent(in) :: xc 
        !DEC$ ATTRIBUTES value :: xc 
        REAL(8), intent(in) :: yc 
        !DEC$ ATTRIBUTES value :: yc 
        integer(LONG) hresult
        integer i
		

        hresult = IDiffraction_PistonTiltFocus(pInterface % pInternalData % pInstanceData ,&
             piston ,&
             xtilt ,&
             ytilt ,&
             focus ,&
             xc ,&
             yc )
        
        if (hresult < 0) goto 9999
    9999  continue  ! Cleanup code
    end function
    function $IDiffraction_PropagateToFocalPlane( pInterface ,&
             lens_f ,&
             lens_D ,&
             dxout ,&
             dyout ,&
             applycurv ,&
             BeamID ,&
             status ) result (hresult)
        !DEC$ ATTRIBUTES STDCALL :: $IDiffraction_PropagateToFocalPlane
        use Diffraction_Types
        use dfcom
        use dflib
        implicit none
        type (IDiffraction_Ptr) pInterface
        !dec$ attributes reference :: pInterface
        REAL(8), intent(in) :: lens_f 
        !DEC$ ATTRIBUTES value :: lens_f 
        REAL(8), intent(in) :: lens_D 
        !DEC$ ATTRIBUTES value :: lens_D 
        REAL(8), intent(in) :: dxout 
        !DEC$ ATTRIBUTES value :: dxout 
        REAL(8), intent(in) :: dyout 
        !DEC$ ATTRIBUTES value :: dyout 
        LOGICAL(4), intent(in) :: applycurv 
        !DEC$ ATTRIBUTES value :: applycurv 
        INTEGER(4), intent(in) :: BeamID 
        !DEC$ ATTRIBUTES value :: BeamID 
        INTEGER(4), intent(out) :: status 
        !DEC$ ATTRIBUTES reference :: status 
        integer(LONG) hresult
        integer i
		

        hresult = IDiffraction_PropagateToFocalPlane(pInterface % pInternalData % pInstanceData ,&
             lens_f ,&
             lens_D ,&
             dxout ,&
             dyout ,&
             applycurv ,&
             BeamID ,&
             status )
        
        if (hresult < 0) goto 9999
    9999  continue  ! Cleanup code
    end function
    function $IDiffraction_ClipCirc( pInterface ,&
             Diameter ,&
             xc ,&
             yc ,&
             obscDiam ) result (hresult)
        !DEC$ ATTRIBUTES STDCALL :: $IDiffraction_ClipCirc
        use Diffraction_Types
        use dfcom
        use dflib
        implicit none
        type (IDiffraction_Ptr) pInterface
        !dec$ attributes reference :: pInterface
        REAL(8), intent(in) :: Diameter 
        !DEC$ ATTRIBUTES value :: Diameter 
        REAL(8), intent(in) :: xc 
        !DEC$ ATTRIBUTES value :: xc 
        REAL(8), intent(in) :: yc 
        !DEC$ ATTRIBUTES value :: yc 
        type(VARIANT), intent(in) :: obscDiam 
        !DEC$ ATTRIBUTES value :: obscDiam 
        integer(LONG) hresult
        integer i
        REAL(8) f$obscDiam
        logical p$obscDiam
        type(VARIANT) v$obscDiam 
        p$obscDiam = .FALSE. 
        if (.not.(obscDiam%vt == VT_ERROR .and. &
            obscDiam%vu%SCODE_VAL == DISP_E_PARAMNOTFOUND)) then
            p$obscDiam = .TRUE.
            i = VariantChangeType(v$obscDiam, obscDiam, 0, VT_R8)
            if (i < 0) then
            hresult = DISP_E_TYPEMISMATCH
            goto 9999
        end if
            f$obscDiam = v$obscDiam%vu%DOUBLE_VAL
        end if 
		
        if (p$obscDiam == .FALSE.) then
            hresult = IDiffraction_ClipCirc(pInterface % pInternalData % pInstanceData, &
                Diameter, &
                xc, &
                yc)
        else
        hresult = IDiffraction_ClipCirc(pInterface % pInternalData % pInstanceData ,&
             Diameter ,&
             xc ,&
             yc ,&
             f$obscDiam )
        end if
        if (hresult < 0) goto 9999
    9999  continue  ! Cleanup code
    end function
    function $IDiffraction_ClipRect( pInterface ,&
             len_x ,&
             len_y ,&
             off_x ,&
             off_y ,&
             obscFlag ) result (hresult)
        !DEC$ ATTRIBUTES STDCALL :: $IDiffraction_ClipRect
        use Diffraction_Types
        use dfcom
        use dflib
        implicit none
        type (IDiffraction_Ptr) pInterface
        !dec$ attributes reference :: pInterface
        REAL(8), intent(in) :: len_x 
        !DEC$ ATTRIBUTES value :: len_x 
        REAL(8), intent(in) :: len_y 
        !DEC$ ATTRIBUTES value :: len_y 
        REAL(8), intent(in) :: off_x 
        !DEC$ ATTRIBUTES value :: off_x 
        REAL(8), intent(in) :: off_y 
        !DEC$ ATTRIBUTES value :: off_y 
        type(VARIANT), intent(in) :: obscFlag 
        !DEC$ ATTRIBUTES value :: obscFlag 
        integer(LONG) hresult
        integer i
        INTEGER(4) f$obscFlag
        logical p$obscFlag
        type(VARIANT) v$obscFlag 
        p$obscFlag = .FALSE. 
        if (.not.(obscFlag%vt == VT_ERROR .and. &
            obscFlag%vu%SCODE_VAL == DISP_E_PARAMNOTFOUND)) then
            p$obscFlag = .TRUE.
            i = VariantChangeType(v$obscFlag, obscFlag, 0, VT_I4)
            if (i < 0) then
            hresult = DISP_E_TYPEMISMATCH
            goto 9999
        end if
            f$obscFlag = v$obscFlag%vu%LONG_VAL
        end if 
		
        if (p$obscFlag == .FALSE.) then
            hresult = IDiffraction_ClipRect(pInterface % pInternalData % pInstanceData, &
                len_x, &
                len_y, &
                off_x, &
                off_y)
        else
        hresult = IDiffraction_ClipRect(pInterface % pInternalData % pInstanceData ,&
             len_x ,&
             len_y ,&
             off_x ,&
             off_y ,&
             f$obscFlag )
        end if
        if (hresult < 0) goto 9999
    9999  continue  ! Cleanup code
    end function
    function $IDiffraction_ClipPolygon( pInterface ,&
             vertices ,&
             xc ,&
             yc ,&
             angle ) result (hresult)
        !DEC$ ATTRIBUTES STDCALL :: $IDiffraction_ClipPolygon
        use Diffraction_Types
        use dfcom
        use dflib
        implicit none
        type (IDiffraction_Ptr) pInterface
        !dec$ attributes reference :: pInterface
        integer(INT_PTR_KIND()), intent(in) :: vertices 
        !DEC$ ATTRIBUTES value :: vertices 
        REAL(8), intent(in) :: xc 
        !DEC$ ATTRIBUTES value :: xc 
        REAL(8), intent(in) :: yc 
        !DEC$ ATTRIBUTES value :: yc 
        REAL(8), intent(in) :: angle 
        !DEC$ ATTRIBUTES value :: angle 
        integer(LONG) hresult
        integer i
        REAL(8) f$vertices(:,:)
        volatile f$vertices
        pointer f$vertices
        integer(INT_PTR_KIND()) ptr$vertices
        integer(INT_PTR_KIND()) sa$vertices
        integer dims$vertices
        integer lb$vertices(2)
        integer ub$vertices(2)
        integer nb$vertices(2)
        type (FOR_DIMS_INFO) da$vertices(2) 
        sa$vertices = NULL
        lb$vertices = 0
        ub$vertices = 0
        nb$vertices = 0 
        
        dims$vertices = SafeArrayGetDim(vertices)
        if (dims$vertices /= 2) then
            hresult = E_INVALIDARG
            goto 9999
        end if
        do i = 1, 2
            hresult = SafeArrayGetLBound(vertices, i, lb$vertices(i))
            hresult = SafeArrayGetUBound(vertices, i, ub$vertices(i))
            nb$vertices(i) = ub$vertices(i) - lb$vertices(i) + 1
        end do
        hresult = SafeArrayAccessData(vertices, ptr$vertices)
        if (hresult < 0) goto 9999
        sa$vertices = vertices
        da$vertices(1)%LowerBound = lb$vertices(1)
        da$vertices(1)%UpperBound = ub$vertices(1)
        da$vertices(1)%Stride = 1
        da$vertices(2)%LowerBound = lb$vertices(2)
        da$vertices(2)%UpperBound = ub$vertices(2)
        da$vertices(2)%Stride = 1
        call FOR_DESCRIPTOR_ASSIGN(f$vertices, ptr$vertices, SIZEOF(f$vertices(lb$vertices(1), lb$vertices(2))), &
             IOR(FOR_DESCRIPTOR_ARRAY_DEFINED, IOR(FOR_DESCRIPTOR_ARRAY_NODEALLOC, FOR_DESCRIPTOR_ARRAY_CONTIGUOUS)), &
             2, da$vertices) 
		

        hresult = IDiffraction_ClipPolygon(pInterface % pInternalData % pInstanceData ,&
             f$vertices ,&
             xc ,&
             yc ,&
             angle )
        
        if (hresult < 0) goto 9999
    9999  continue  ! Cleanup code
        
        if (sa$vertices /= NULL) i = SafeArrayUnaccessData(sa$vertices) 
    end function
    function $IDiffraction_ClipBWindow( pInterface ,&
             winT ,&
             winA ,&
             xc ,&
             yc ,&
             rotAngle ) result (hresult)
        !DEC$ ATTRIBUTES STDCALL :: $IDiffraction_ClipBWindow
        use Diffraction_Types
        use dfcom
        use dflib
        implicit none
        type (IDiffraction_Ptr) pInterface
        !dec$ attributes reference :: pInterface
        REAL(8), intent(in) :: winT 
        !DEC$ ATTRIBUTES value :: winT 
        REAL(8), intent(in) :: winA 
        !DEC$ ATTRIBUTES value :: winA 
        REAL(8), intent(in) :: xc 
        !DEC$ ATTRIBUTES value :: xc 
        REAL(8), intent(in) :: yc 
        !DEC$ ATTRIBUTES value :: yc 
        REAL(8), intent(in) :: rotAngle 
        !DEC$ ATTRIBUTES value :: rotAngle 
        integer(LONG) hresult
        integer i
		

        hresult = IDiffraction_ClipBWindow(pInterface % pInternalData % pInstanceData ,&
             winT ,&
             winA ,&
             xc ,&
             yc ,&
             rotAngle )
        
        if (hresult < 0) goto 9999
    9999  continue  ! Cleanup code
    end function
    function $IDiffraction_AddThreadCommand( pInterface ,&
             ThreadID ,&
             CmdID ,&
             rP ,&
             iP ,&
             pwAID ,&
             pwBID ,&
             strP ,&
             flagStatus ) result (hresult)
        !DEC$ ATTRIBUTES STDCALL :: $IDiffraction_AddThreadCommand
        use Diffraction_Types
        use dfcom
        use dflib
        implicit none
        type (IDiffraction_Ptr) pInterface
        !dec$ attributes reference :: pInterface
        INTEGER(4), intent(in) :: ThreadID 
        !DEC$ ATTRIBUTES value :: ThreadID 
        INTEGER(4), intent(in) :: CmdID 
        !DEC$ ATTRIBUTES value :: CmdID 
        integer(INT_PTR_KIND()), intent(in) :: rP 
        !DEC$ ATTRIBUTES value :: rP 
        integer(INT_PTR_KIND()), intent(in) :: iP 
        !DEC$ ATTRIBUTES value :: iP 
        INTEGER(4), intent(in) :: pwAID 
        !DEC$ ATTRIBUTES value :: pwAID 
        INTEGER(4), intent(in) :: pwBID 
        !DEC$ ATTRIBUTES value :: pwBID 
        integer(INT_PTR_KIND()), intent(in) :: strP 
        !DEC$ ATTRIBUTES value :: strP 
        INTEGER(4), intent(out) :: flagStatus 
        !DEC$ ATTRIBUTES reference :: flagStatus 
        integer(LONG) hresult
        integer i
        REAL(8) f$rP(:,:)
        volatile f$rP
        pointer f$rP
        integer(INT_PTR_KIND()) ptr$rP
        integer(INT_PTR_KIND()) sa$rP
        integer dims$rP
        integer lb$rP(2)
        integer ub$rP(2)
        integer nb$rP(2)
        type (FOR_DIMS_INFO) da$rP(2) 
        INTEGER(4) f$iP(:,:)
        volatile f$iP
        pointer f$iP
        integer(INT_PTR_KIND()) ptr$iP
        integer(INT_PTR_KIND()) sa$iP
        integer dims$iP
        integer lb$iP(2)
        integer ub$iP(2)
        integer nb$iP(2)
        type (FOR_DIMS_INFO) da$iP(2) 
        character(len=SysStringLen_Local(strP)) f$strP 
        sa$rP = NULL
        lb$rP = 0
        ub$rP = 0
        nb$rP = 0 
        sa$iP = NULL
        lb$iP = 0
        ub$iP = 0
        nb$iP = 0 
        
        dims$rP = SafeArrayGetDim(rP)
        if (dims$rP /= 2) then
            hresult = E_INVALIDARG
            goto 9999
        end if
        do i = 1, 2
            hresult = SafeArrayGetLBound(rP, i, lb$rP(i))
            hresult = SafeArrayGetUBound(rP, i, ub$rP(i))
            nb$rP(i) = ub$rP(i) - lb$rP(i) + 1
        end do
        hresult = SafeArrayAccessData(rP, ptr$rP)
        if (hresult < 0) goto 9999
        sa$rP = rP
        da$rP(1)%LowerBound = lb$rP(1)
        da$rP(1)%UpperBound = ub$rP(1)
        da$rP(1)%Stride = 1
        da$rP(2)%LowerBound = lb$rP(2)
        da$rP(2)%UpperBound = ub$rP(2)
        da$rP(2)%Stride = 1
        call FOR_DESCRIPTOR_ASSIGN(f$rP, ptr$rP, SIZEOF(f$rP(lb$rP(1), lb$rP(2))), &
             IOR(FOR_DESCRIPTOR_ARRAY_DEFINED, IOR(FOR_DESCRIPTOR_ARRAY_NODEALLOC, FOR_DESCRIPTOR_ARRAY_CONTIGUOUS)), &
             2, da$rP) 
        
        dims$iP = SafeArrayGetDim(iP)
        if (dims$iP /= 2) then
            hresult = E_INVALIDARG
            goto 9999
        end if
        do i = 1, 2
            hresult = SafeArrayGetLBound(iP, i, lb$iP(i))
            hresult = SafeArrayGetUBound(iP, i, ub$iP(i))
            nb$iP(i) = ub$iP(i) - lb$iP(i) + 1
        end do
        hresult = SafeArrayAccessData(iP, ptr$iP)
        if (hresult < 0) goto 9999
        sa$iP = iP
        da$iP(1)%LowerBound = lb$iP(1)
        da$iP(1)%UpperBound = ub$iP(1)
        da$iP(1)%Stride = 1
        da$iP(2)%LowerBound = lb$iP(2)
        da$iP(2)%UpperBound = ub$iP(2)
        da$iP(2)%Stride = 1
        call FOR_DESCRIPTOR_ASSIGN(f$iP, ptr$iP, SIZEOF(f$iP(lb$iP(1), lb$iP(2))), &
             IOR(FOR_DESCRIPTOR_ARRAY_DEFINED, IOR(FOR_DESCRIPTOR_ARRAY_NODEALLOC, FOR_DESCRIPTOR_ARRAY_CONTIGUOUS)), &
             2, da$iP) 
        
        i = ConvertBSTRToString(strP, f$strP) 
		

        hresult = IDiffraction_AddThreadCommand(pInterface % pInternalData % pInstanceData ,&
             ThreadID ,&
             CmdID ,&
             f$rP ,&
             f$iP ,&
             pwAID ,&
             pwBID ,&
             f$strP ,&
             flagStatus )
        
        if (hresult < 0) goto 9999
    9999  continue  ! Cleanup code
        
        if (sa$rP /= NULL) i = SafeArrayUnaccessData(sa$rP) 
        
        if (sa$iP /= NULL) i = SafeArrayUnaccessData(sa$iP) 
    end function
    function $IDiffraction_ExecuteThread( pInterface ,&
             ThreadID ,&
             flagStatus ) result (hresult)
        !DEC$ ATTRIBUTES STDCALL :: $IDiffraction_ExecuteThread
        use Diffraction_Types
        use dfcom
        use dflib
        implicit none
        type (IDiffraction_Ptr) pInterface
        !dec$ attributes reference :: pInterface
        INTEGER(4), intent(in) :: ThreadID 
        !DEC$ ATTRIBUTES value :: ThreadID 
        INTEGER(4), intent(out) :: flagStatus 
        !DEC$ ATTRIBUTES reference :: flagStatus 
        integer(LONG) hresult
        integer i
		

        hresult = IDiffraction_ExecuteThread(pInterface % pInternalData % pInstanceData ,&
             ThreadID ,&
             flagStatus )
        
        if (hresult < 0) goto 9999
    9999  continue  ! Cleanup code
    end function
    function $IDiffraction_ThreadStatus( pInterface ,&
             ThreadID ,&
             flagStatus ) result (hresult)
        !DEC$ ATTRIBUTES STDCALL :: $IDiffraction_ThreadStatus
        use Diffraction_Types
        use dfcom
        use dflib
        implicit none
        type (IDiffraction_Ptr) pInterface
        !dec$ attributes reference :: pInterface
        INTEGER(4), intent(in) :: ThreadID 
        !DEC$ ATTRIBUTES value :: ThreadID 
        INTEGER(4), intent(out) :: flagStatus 
        !DEC$ ATTRIBUTES reference :: flagStatus 
        integer(LONG) hresult
        integer i
		

        hresult = IDiffraction_ThreadStatus(pInterface % pInternalData % pInstanceData ,&
             ThreadID ,&
             flagStatus )
        
        if (hresult < 0) goto 9999
    9999  continue  ! Cleanup code
    end function
    function $IDiffraction_WaitForThread( pInterface ,&
             ThreadID ,&
             TimeOutMS ,&
             WaitStatus ) result (hresult)
        !DEC$ ATTRIBUTES STDCALL :: $IDiffraction_WaitForThread
        use Diffraction_Types
        use dfcom
        use dflib
        implicit none
        type (IDiffraction_Ptr) pInterface
        !dec$ attributes reference :: pInterface
        INTEGER(4), intent(in) :: ThreadID 
        !DEC$ ATTRIBUTES value :: ThreadID 
        INTEGER(4), intent(in) :: TimeOutMS 
        !DEC$ ATTRIBUTES value :: TimeOutMS 
        INTEGER(4), intent(out) :: WaitStatus 
        !DEC$ ATTRIBUTES reference :: WaitStatus 
        integer(LONG) hresult
        integer i
		

        hresult = IDiffraction_WaitForThread(pInterface % pInternalData % pInstanceData ,&
             ThreadID ,&
             TimeOutMS ,&
             WaitStatus )
        
        if (hresult < 0) goto 9999
    9999  continue  ! Cleanup code
    end function
    function $IDiffraction_WaitForMultipleThreads( pInterface ,&
             pThreadID ,&
             TimeOutMS ,&
             flagWaitAll ,&
             WaitStatus ) result (hresult)
        !DEC$ ATTRIBUTES STDCALL :: $IDiffraction_WaitForMultipleThreads
        use Diffraction_Types
        use dfcom
        use dflib
        implicit none
        type (IDiffraction_Ptr) pInterface
        !dec$ attributes reference :: pInterface
        integer(INT_PTR_KIND()), intent(in) :: pThreadID 
        !DEC$ ATTRIBUTES value :: pThreadID 
        INTEGER(4), intent(in) :: TimeOutMS 
        !DEC$ ATTRIBUTES value :: TimeOutMS 
        INTEGER(4), intent(in) :: flagWaitAll 
        !DEC$ ATTRIBUTES value :: flagWaitAll 
        INTEGER(4), intent(out) :: WaitStatus 
        !DEC$ ATTRIBUTES reference :: WaitStatus 
        integer(LONG) hresult
        integer i
        INTEGER(4) f$pThreadID(:,:)
        volatile f$pThreadID
        pointer f$pThreadID
        integer(INT_PTR_KIND()) ptr$pThreadID
        integer(INT_PTR_KIND()) sa$pThreadID
        integer dims$pThreadID
        integer lb$pThreadID(2)
        integer ub$pThreadID(2)
        integer nb$pThreadID(2)
        type (FOR_DIMS_INFO) da$pThreadID(2) 
        sa$pThreadID = NULL
        lb$pThreadID = 0
        ub$pThreadID = 0
        nb$pThreadID = 0 
        
        dims$pThreadID = SafeArrayGetDim(pThreadID)
        if (dims$pThreadID /= 2) then
            hresult = E_INVALIDARG
            goto 9999
        end if
        do i = 1, 2
            hresult = SafeArrayGetLBound(pThreadID, i, lb$pThreadID(i))
            hresult = SafeArrayGetUBound(pThreadID, i, ub$pThreadID(i))
            nb$pThreadID(i) = ub$pThreadID(i) - lb$pThreadID(i) + 1
        end do
        hresult = SafeArrayAccessData(pThreadID, ptr$pThreadID)
        if (hresult < 0) goto 9999
        sa$pThreadID = pThreadID
        da$pThreadID(1)%LowerBound = lb$pThreadID(1)
        da$pThreadID(1)%UpperBound = ub$pThreadID(1)
        da$pThreadID(1)%Stride = 1
        da$pThreadID(2)%LowerBound = lb$pThreadID(2)
        da$pThreadID(2)%UpperBound = ub$pThreadID(2)
        da$pThreadID(2)%Stride = 1
        call FOR_DESCRIPTOR_ASSIGN(f$pThreadID, ptr$pThreadID, SIZEOF(f$pThreadID(lb$pThreadID(1), lb$pThreadID(2))), &
             IOR(FOR_DESCRIPTOR_ARRAY_DEFINED, IOR(FOR_DESCRIPTOR_ARRAY_NODEALLOC, FOR_DESCRIPTOR_ARRAY_CONTIGUOUS)), &
             2, da$pThreadID) 
		

        hresult = IDiffraction_WaitForMultipleThreads(pInterface % pInternalData % pInstanceData ,&
             f$pThreadID ,&
             TimeOutMS ,&
             flagWaitAll ,&
             WaitStatus )
        
        if (hresult < 0) goto 9999
    9999  continue  ! Cleanup code
        
        if (sa$pThreadID /= NULL) i = SafeArrayUnaccessData(sa$pThreadID) 
    end function
    function $IDiffraction_ClearThread( pInterface ,&
             ThreadID ,&
             flagStatus ) result (hresult)
        !DEC$ ATTRIBUTES STDCALL :: $IDiffraction_ClearThread
        use Diffraction_Types
        use dfcom
        use dflib
        implicit none
        type (IDiffraction_Ptr) pInterface
        !dec$ attributes reference :: pInterface
        INTEGER(4), intent(in) :: ThreadID 
        !DEC$ ATTRIBUTES value :: ThreadID 
        INTEGER(4), intent(out) :: flagStatus 
        !DEC$ ATTRIBUTES reference :: flagStatus 
        integer(LONG) hresult
        integer i
		

        hresult = IDiffraction_ClearThread(pInterface % pInternalData % pInstanceData ,&
             ThreadID ,&
             flagStatus )
        
        if (hresult < 0) goto 9999
    9999  continue  ! Cleanup code
    end function
    function $IDiffraction_get_ThreadOPD( pInterface ,&
             ThreadID ,&
             OPDID ,&
             VALUE ) result (hresult)
        !DEC$ ATTRIBUTES STDCALL :: $IDiffraction_get_ThreadOPD
        use Diffraction_Types
        use dfcom
        use dflib
        implicit none
        type (IDiffraction_Ptr) pInterface
        !dec$ attributes reference :: pInterface
        INTEGER(4), intent(in) :: ThreadID 
        !DEC$ ATTRIBUTES value :: ThreadID 
        INTEGER(4), intent(in) :: OPDID 
        !DEC$ ATTRIBUTES value :: OPDID 
        REAL(8), intent(out) :: VALUE 
        !DEC$ ATTRIBUTES reference :: VALUE 
        integer(LONG) hresult
        integer i
		

        hresult = IDiffraction_get_ThreadOPD(pInterface % pInternalData % pInstanceData ,&
             ThreadID ,&
             OPDID ,&
             VALUE )
        
        if (hresult < 0) goto 9999
    9999  continue  ! Cleanup code
    end function
    function $IDiffraction_get_ThreadPOW( pInterface ,&
             ThreadID ,&
             POWID ,&
             VALUE ) result (hresult)
        !DEC$ ATTRIBUTES STDCALL :: $IDiffraction_get_ThreadPOW
        use Diffraction_Types
        use dfcom
        use dflib
        implicit none
        type (IDiffraction_Ptr) pInterface
        !dec$ attributes reference :: pInterface
        INTEGER(4), intent(in) :: ThreadID 
        !DEC$ ATTRIBUTES value :: ThreadID 
        INTEGER(4), intent(in) :: POWID 
        !DEC$ ATTRIBUTES value :: POWID 
        REAL(8), intent(out) :: VALUE 
        !DEC$ ATTRIBUTES reference :: VALUE 
        integer(LONG) hresult
        integer i
		

        hresult = IDiffraction_get_ThreadPOW(pInterface % pInternalData % pInstanceData ,&
             ThreadID ,&
             POWID ,&
             VALUE )
        
        if (hresult < 0) goto 9999
    9999  continue  ! Cleanup code
    end function
end module

